const fs = require('fs');
let ocrClient;

exports.InitOcr = async (appId, apiKey, secretKey)=>{
    let ocrSdk = require("baidu-aip-sdk");
    let AipOcrClient = ocrSdk.ocr;
    ocrClient = new AipOcrClient(appId, apiKey, secretKey);
    //设置超时
    let HttpClient = ocrSdk.HttpClient;
    HttpClient.setRequestOptions({timeout: 5000});
}

exports.GetImageWords = async (imagePath, ocrType)=>{
    let retWords = "";
    let image = await fs.readFileSync(imagePath).toString("base64");
    let ocrFunction;
    switch(ocrType)
    {
        case 1://通用文字识别
            ocrFunction = ocrClient.generalBasic(image);
            break;
        case 2://高精度版
            ocrFunction = ocrClient.accurateBasic(image);
            break;
        case 3://网络图片文字识别
            ocrFunction = ocrClient.webImage(image);
            break;
        case 4://数字识别 自动过滤非数字内容
            ocrFunction = ocrClient.numbers(image);
            break;
        case 5://手写文字识别
            ocrFunction = ocrClient.handwriting(image);
            break;
        case 6://二维码识别
            ocrFunction = ocrClient.qrcode(image);
            break;
    }

    //调用文字识别, 图片参数为本地图片
    await ocrFunction.then(result => {
        let wordsCount, wordsResult;
        if(ocrType == 5){
            //二维码识别,特殊处理
            wordsCount = result.codes_result_num;
            wordsResult = result.codes_result;
        }
        else{
            wordsCount = result.words_result_num;
            wordsResult = result.words_result;
        }
        for(let i = 0; i < wordsCount; i++){
            if(ocrType == 5)//二维码识别,特殊处理
                retWords += wordsResult[i].text + "\n";
            else
                retWords += wordsResult[i].words + "\n";
        }
    }).catch(err => {
        // 如果发生网络错误
        console.log(err);
        retWords = null;
    });
    return retWords;
}

exports.FindImageWords = async (imagePath, words, index = 0)=>{
    let point = {'x':-1, 'y':-1};
    let image = await fs.readFileSync(imagePath).toString("base64");
    let options = {};
    let wordsLen = words.length;
    if(wordsLen == 1)
        options["recognize_granularity"] = "small";
    else
        options["recognize_granularity"] = "big";
    // 调用通用文字识别（含位置信息版）, 图片参数为本地图片
    await ocrClient.general(image, options).then(result=>{
        let wordsCount = result.words_result_num;
        let wordsResult = result.words_result;
        for(let i = 0; i < wordsCount; i++){
            if(wordsLen == 1){
                let chars = wordsResult[i].chars;
                let charCount = chars.length;

                for(let j = 0; j < charCount; j++){
                    if(chars[j].char == words){
                        if(index == 0){
                            point.x = chars[j].location.left + chars[j].location.width / 2;
                            point.y = chars[j].location.top + chars[j].location.height / 2;
                            return ;
                        }
                        index--;
                    }
                }
            }
            else{
                let wordsIndex, wordWidth, destWords, wordsLocation;
                destWords = wordsResult[i].words;
                wordsIndex = destWords.indexOf(words);
                if(wordsIndex != -1){
                    wordsLocation = wordsResult[i].location;
                    //获取单个字符的长度，不考虑竖排列文字
                    wordWidth = wordsLocation.width / destWords.length;
                    if(index == 0){
                        //获取目标文字在整个字符串的位置,字体大小不一，可能会有误差
                        point.x = wordsLocation.left + wordWidth * (wordsIndex + wordsLen / 2);
                        point.y = wordsLocation.top + wordsLocation.height / 2;
                        return ;
                    }
                    index--;
                }
            }
        }
    }).catch(err => {
        // 如果发生网络错误
        console.log(err);
    });

    if(point.x == -1 && point.y == -1)
        return null;
    else
        return point;
}