const net = require('net');
const child_process = require('child_process');
const officegen = require('officegen');
const textract = require('textract');
const nodemailer = require("nodemailer");
const Imap = require('imap');
const MailParser = require("mailparser").MailParser;
const pdf2png = require("WindowsBot/pdf2png/lib/pdf2png.js");
const fs = require('fs');
const ocr = require("./ocr");
const Client = require('@alicloud/nls-filetrans-2018-08-17');
const OSS = require('ali-oss');
const request = require('request');
const path = require("path");
const https = require('https');
const http = require('http');
const compressing = require('compressing');

/**睡眠等待
 * @param {number} millisecond  等待时间,单位毫秒
 * @return {Promise}
*/
exports.Sleep = (millisecond) => {
  return new Promise(resolve => {setTimeout(() => {resolve()}, millisecond)});
}

exports.DownloadAi_Bot = async (url = null) => {
  return new Promise((resolve) => {
    let  protocol;
    let ai_botPath = process.cwd();
    let zipPath = ai_botPath + "\\Ai-Bot2.0.zip";
    let evn = process.env;
    if(url == null || process.execPath.indexOf(".exe") == -1 || evn["Ai_BOT"] != undefined){
        resolve(false);
        return false;
    }
    console.log("发现系统未安装机器人框架环境");
    
    if(url.indexOf("https:") != -1)
        protocol = https;
    else
        protocol = http;

    console.log("正在下载机器人框架环境...");
    protocol.get(url, (response)=>{
        if(response.statusCode !== 200){
            console.log("下载失败");
            resolve(false);
            return false;
        }
        response.pipe(fs.createWriteStream(zipPath)).on('finish', ()=>{
            resolve(true);
            return true;
        });
    });
  });
}

exports.InstallAi_Bot = async () => {
  let ai_botPath = process.cwd();
  let zipPath = ai_botPath + "\\Ai-Bot2.0.zip";
  let exePath = ai_botPath + "\\Ai-Bot2.0\\Ai-Bot.exe";

  console.log("正在安装机器人框架环境...");
  await compressing.zip.uncompress(zipPath, ai_botPath);
  await this.Sleep(2000);
  await child_process.execFile(exePath);
  await fs.unlinkSync(zipPath);
}

/**初始化socket并启动WindowsBot
 * @param {number} windowsBotPort  WindowsBot服务端口,多开进程端口不可重复
 * @param {string} proxyServer 设置WebBot内置浏览器代理ip
 * @param {string} ai_botLink aibot链接
 * @return {WindowsObject} 成功返回WindowsObject
*/
exports.InitWindowsBot = async (windowsBotPort, proxyServer = null, ai_botLink = null)=>{
  if(await this.DownloadAi_Bot(ai_botLink)){
    await this.Sleep(2000);
    await this.InstallAi_Bot();
  }
  
  if(proxyServer != null)
    proxyServer = '--proxy-server=' + proxyServer;
  child_process.execFile('WindowsBot', [windowsBotPort, proxyServer]);
  
  await this.Sleep(1000);//等待WindowsBot打开通信
  return new Promise((resolve) => {
    new WindowsObject(windowsBotPort, resolve);
  })
}

class WindowsObject{
  constructor(windowsBotPort, resolve) {
    this.socket = new net.Socket();
    this.resolveHand = resolve;
    this.recvData = "";
    this.recvDataLen = 0;//接收总长度
    this.isFirstData = true;//标记write首次触发data事件
    this.waitTimeout = 0;//隐式等待超时
    this.intervalTimeout = 1;//每次等待的时间
    this.captchaId;//用于验证码识别错误提交

    this.socket.setEncoding = 'UTF-8';
    this.socket.connect(windowsBotPort);

    this.socket.on('connect', ()=>{
      console.log("WindowsBot连接成功!");
      this.resolveHand(this);//返回WindowsObject
      this.resolveHand = null;
    });
  
    this.socket.on('error', error=>{
      console.log('连接错误' + error);
    });
    
    this.socket.on('close', ()=>{
      console.log('WindowsBot连接已关闭');
    });
    
    //接收c++数据
    this.socket.on('data', data => {
      this.recvData += data.toString();
      if(this.isFirstData)
      {
        this.isFirstData = false;
        this.recvDataLen = parseInt(this.recvData.substr(0, 6), 16);
        //获取数据内容
        this.recvData = this.recvData.substr(6);
      }
    
      if (this.resolveHand && this.recvDataLen == this.recvData.length) {
        //清理现场
        this.isFirstData = true;
        this.resolveHand(this.recvData);
        this.recvData = "";
        this.resolveHand = null;
      }
    });
  }

  //发送数据到c++并等待返回
  async clientPipeServer(sendData){
    return new Promise((resolve) => {
        this.resolveHand = resolve;
        this.socket.write(sendData);
    })
  }

  setSendData (...arrArgs){
    // len/len/len\ndata
    let strData = "";
    let tempStr = "";
    arrArgs.forEach((args) =>{
      if(args == null)
        args = "";
      tempStr += args;
      strData += args.toString().length;
      strData += '/';
    });
    strData += '\n';
    strData += tempStr;
    return strData;
  }

  //element 转换成对象，便于释放清0 
  async formatElement(element){
    let strObjElement = '{"v":'; 
    strObjElement += element;
    strObjElement += '}';
    return JSON.parse(strObjElement);
  }
  //elements
  async formatElements(elements){
    let strObjElement;
    for(let i = 0; i < elements.length; i++){
      strObjElement = '{"v":';
      strObjElement += elements[i];
      strObjElement += '}';
      elements[i] = JSON.parse(strObjElement); 
    }
    return elements;
  }

  //格式化 rect
  async formatRect(strRect){
    let arrRect = strRect.split("\n");
    let objRect = '{"left":' + arrRect[0] + ',"top":' + arrRect[1] + ',"right":' + arrRect[2] +',"bottom":' + arrRect[3] + ',"width":' + arrRect[4] + ',"height":' + arrRect[5] + '}';
    return JSON.parse(objRect);
  }

  /**断开socket清理现场,并关闭WindowsBot
   * @return {void} 
  */
  async CloseWindowsBot(){
    this.socket.destroy();
    this.resolveHand = null
    this.recvData = "";
    this.recvDataLen = 0;
    this.isFirstData = true;
  }

  /**睡眠等待
   * @param {number} millisecond  等待时间,单位毫秒
   * @return {Promise}
  */
  async Sleep(millisecond){
    return new Promise(resolve => {setTimeout(() => {resolve()}, millisecond)});
  }

  /**设置隐式等待时间,设定全局窗口和元素查找超时
   * @param {number} waitMs  等待时间,单位毫秒
   * @param {number} intervalMs 心跳间隔，单位毫秒。可选参数，默认10毫秒
  */
  async SetImplicitTimeout(waitMS, intervalMS = 10){
    this.waitTimeout = waitMS;
    this.intervalTimeout = intervalMS;
  }

  /**设置当前操作模式
   * @param {boolean} mode  true前台,false后台,WindowsBot默认前台操作
   * @return {boolean} 总是返回true
  */
  async SetCurMode(mode){
    let strData = this.setSendData('SetCurMode', mode);
    await this.clientPipeServer(strData);
    return true;
  }

  /**查找WebBot内置浏览器句柄
   * @return {number} 成功返回句柄,失败返回null
  */
  async FindWebBotHandle(){
    let strData = this.setSendData('FindWebBotHandle');
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return strRet;
  }

  /**查找窗口句柄
   * @param {string} className 窗口类名
   * @param {string} windowName 窗口标题
   * @return {number} 成功返回句柄,失败返回null
  */
  async FindWindowHandle(className, windowName){
    let strData = this.setSendData('FindWindowHandle', className, windowName);

    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet;
    }
    return null;
  }

  /**查找窗口句柄数组
   * @param {string} className 窗口类名
   * @param {string} windowName 窗口标题
   * @return {number[]} 成功返回句柄数组,失败返回null
  */
  async FindWindowsHandle(className, windowName){
    let strData = this.setSendData('FindWindowsHandle', className, windowName);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet.split("\n");
    }
    return null;
  }

  /**查找子窗口句柄
   * @param {number} hwndParent 父窗口句柄
   * @param {string} className 窗口类名
   * @param {string} windowName 窗口标题
   * @return {number} 成功返回句柄,失败返回null
  */
  async FindSubWindowHandle(hwndParent, className, windowName){
    let strData = this.setSendData('FindSubWindowHandle', hwndParent, className, windowName);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet;
    }
    return null;
  }

  /**查找父窗口句柄
   * @param {number} hwndSub 子窗口句柄
   * @return {number} 成功返回句柄,失败返回null
  */
  async FindParentWindowHandle(hwndSub){
    let strData = this.setSendData('FindParentWindowHandle', hwndSub);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet;
    }
    return null;
  }

  /**显示/隐藏窗口
   * @param {number} hwnd 窗口句柄
   * @param {boolean} isShow true显示窗口，false隐藏窗口
   * @return {boolean} 成功返回true，失败返回false
  */
  async ShowWindow(hwnd, isShow){
    let strData = this.setSendData('ShowWindow', hwnd, isShow);
    return await this.clientPipeServer(strData);
  }

  /**移动鼠标
   * @param {number} hwnd 窗口句柄
   * @param {number} x x坐标
   * @param {number} y y坐标
   * @return {boolean} 总是返回true
  */
  async MoveMouse(hwnd, x, y){
    let strData = this.setSendData('MoveMouse', hwnd, x, y);
    return await this.clientPipeServer(strData);
  }

  /**滚动鼠标
   * @param {number} hwnd 窗口句柄
   * @param {number} x x坐标
   * @param {number} y y坐标
   * @param {number} dwData 鼠标滚动次数,负数下滚鼠标,正数上滚鼠标
   * @return {boolean} 总是返回true
  */
  async RollMouse(hwnd, x, y, dwData){
    let strData = this.setSendData('RollMouse', hwnd, x, y, dwData);
    return await this.clientPipeServer(strData);
  }

  /**点击鼠标,后台模式下,控件有单独句柄时候会失败
   * @param {number} hwnd 窗口句柄
   * @param {number} x x坐标
   * @param {number} y y坐标
   * @param {number} msg 单击左键:1 单击右键:2 按下左键:3 弹起左键:4 按下右键:5 弹起右键:6 双击左键:7 双击右键:8
   * @return {boolean} 总是返回true
  */
  async ClickMouse(hwnd, x, y, msg){
    let strData = this.setSendData('ClickMouse', hwnd, x, y, msg);
    return await this.clientPipeServer(strData);
  }

  /**输入文本,杀毒软件可能会拦截
   * @param {number} hwnd 窗口句柄
   * @param {string} text 输入内容
   * @return {boolean} 总是返回true
  */
  async InputText(hwnd, text){
    let strData = this.setSendData('InputText', hwnd, text);
    return await this.clientPipeServer(strData);
  }

  /**输入键盘VK值
   * @param {number} bVk VK键值
   * @param {number} msg 按下弹起:1 按下:2 弹起:3
   * @return {boolean} 总是返回true
  */
  async InputKeyborad(bVk, msg){
    let strData = this.setSendData('InputKeyborad', bVk, msg);
    return await this.clientPipeServer(strData);
  }

  /**截图保存
   * @param {number} hwnd 窗口句柄
   * @param {string} imagePath 图片保存的路径, png格式
   * @param {number} x 可选参数,顶点x坐标
   * @param {number} y 可选参数,顶点y坐标
   * @param {number} width 可选参数,图片宽度
   * @param {number} height 可选参数,图片高度
   * @return {boolean} 成功返回true,失败返回false
  */
  async SaveScreenshot(hwnd, imagePath, x = 0, y =0, width = 0, height = 0){
    let strData = this.setSendData('SaveScreenshot', hwnd, imagePath, x, y, width, height);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**前台截图保存,当SaveScreenshot截图失效时,可用此函数
   * @param {string} imagePath 图片保存的路径, png格式
   * @param {number} x 可选参数,顶点x坐标
   * @param {number} y 可选参数,顶点y坐标
   * @param {number} width 可选参数,图片宽度
   * @param {number} height 可选参数,图片高度
   * @return {boolean} 成功返回true,失败返回false
  */
  async FrontSaveScreenshot(imagePath, x = 0, y =0, width = 0, height = 0){
    let strData = this.setSendData('FrontSaveScreenshot', imagePath, x, y, width, height);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**查找图片颜色点的数量和坐标
   * @param {string} imagePath 图片的路径
   * @param {number} R 红
   * @param {number} G 绿
   * @param {number} B 蓝
   * @return {string} 返回指定rgb点的数量和坐标
  */
  async FindColorCount(imagePath, R, G, B){
    let strData = this.setSendData('FindColorCount', imagePath, R, G, B);
    return await this.clientPipeServer(strData);
  }

  /**查找指定色值在图片上的位置
   * @param {number} hwnd 窗口句柄
   * @param {string} imagePath 图片的路径
   * @param {number} R 红
   * @param {number} G 绿
   * @param {number} B 蓝
   * @param {number} index 可选参数,指定出现的次数,默认第一次查找到的坐标
   * @return {{x:number, y:number}} 返回指定rgb点的坐标,失败返回 {x:-1, y:-1}
  */
  async FindColor(hwnd, imagePath, R, G, B, index = 0){
    let strData = this.setSendData('FindColor', hwnd, imagePath, R, G, B, index);
    return JSON.parse(await this.clientPipeServer(strData));
  }

  /**查找图片,大图找小图
   * @param {number} hwnd 窗口句柄
   * @param {string} sourceImagePath 大图路径
   * @param {string} destImagePath 小图路径
   * @param {number} sim 相似度0.0-1.0
   * @return {{x:number, y:number}} 返回指定图片的坐标,失败返回 {x:-1, y:-1}
  */
  async FindImage(hwnd, sourceImagePath, destImagePath, sim){
    let strData = this.setSendData('FindImage', hwnd, sourceImagePath, destImagePath, sim);
    return JSON.parse(await this.clientPipeServer(strData));
  }

  /**设置剪切板文本
   * @param {string} text 设置的文本
   * @return {boolean} 总是返回true
  */
  async SetClipboardText(text){
    let strData = this.setSendData('SetClipboardText', text);
    return await this.clientPipeServer(strData);
  }

  /**获取剪切板文本
   * @return {string} 返回剪切板文本
  */
  async GetClipboardText(){
    let strData = this.setSendData('GetClipboardText');
    return await this.clientPipeServer(strData);
  }

  /**启动指定程序
   * @param {string} commandLine 启动命令行
   * @param {boolean} showWindow 是否显示窗口。可选参数,默认显示窗口
   * @param {boolean} isWait 是否等待程序结束。可选参数,默认不等待
   * @return {boolean} 成功返回true,失败返回false
  */
  async StartProcess(commandLine, showWindow = true, isWait = false){
    let strData = this.setSendData('StartProcess', commandLine, showWindow, isWait);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**指定url下载文件
   * @param {string} url 文件地址
   * @param {string} filePath 文件保存的路径
   * @param {boolean} isWait 是否等待.为true时,等待下载完成
   * @return {boolean} 总是返回true
  */
  async DownloadFile(url, filePath, isWait){
    let strData = this.setSendData('DownloadFile', url, filePath, isWait);
    return await this.clientPipeServer(strData);
  }

  /**查找窗口根元素
   * @param {number} hwnd 窗口句柄
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindRootElement(hwnd){
    let strData = this.setSendData('FindRootElement', hwnd);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElement(strRet);
    }
    return null;
  }

  /**查找焦点元素
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindFocusElement(){
    let strData = this.setSendData('FindFocusElement');
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElement(strRet);
    }
    return null;
  }

  /**通过automationId查找元素
   * @param {Object} rootElement 根元素
   * @param {string} automationId 要查找元素的automationId值
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindElementByAutomationId(rootElement, automationId){
    let strData = this.setSendData('FindElementByAutomationId', rootElement.v, automationId);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElement(strRet);
    }
    return null;
  }

  /**通过automationId查找元素数组
   * @param {Object} rootElement 根元素
   * @param {string} automationId 要查找元素的automationId值
   * @return {Object[]} 成功返回元素对象数组，失败返回null
  */
  async FindElementsByAutomationId(rootElement, automationId){
    let strData = this.setSendData('FindElementsByAutomationId', rootElement.v, automationId);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElements(strRet.split("\n"));
    }
    return null;
  }

  /**通过name查找元素
   * @param {Object} rootElement 根元素
   * @param {string} name 要查找元素的name值
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindElementByName(rootElement, name){
    let strData = this.setSendData('FindElementByName', rootElement.v, name);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElement(strRet);
    }
    return null;
  }

  /**通过name查找元素数组
   * @param {Object} rootElement 根元素
   * @param {string} name 要查找元素的name值
   * @return {Object[]} 成功返回元素对象数组，失败返回null
  */
  async FindElementsByName(rootElement, name){
    let strData = this.setSendData('FindElementsByName', rootElement.v, name);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElements(strRet.split("\n"));
    }
    return null;
  }

  /**通过className查找元素
   * @param {Object} rootElement 根元素
   * @param {string} className 要查找元素的className值
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindElementByClassName(rootElement, className){
    let strData = this.setSendData('FindElementByClassName', rootElement.v, className);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElement(strRet);
    }
    return null;
  }

  /**通过className查找元素数组
   * @param {Object} rootElement 根元素
   * @param {string} className 要查找元素的className值
   * @return {Object[]} 成功返回元素对象数组，失败返回null
  */
  async FindElementsByClassName(rootElement, className){
    let strData = this.setSendData('FindElementsByClassName', rootElement.v, className);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElements(strRet.split("\n"));
    }
    return null;
  }

  /**通过controlType查找元素
   * @param {Object} rootElement 根元素
   * @param {string} controlType 要查找元素的controlType值
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindElementByControlType(rootElement, controlType){
    let strData = this.setSendData('FindElementByControlType', rootElement.v, controlType);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElement(strRet);
    }
    return null;
  }

  /**通过controlType查找元素数组
   * @param {Object} rootElement 根元素
   * @param {string} controlType 要查找元素的controlType值
   * @return {Object[]} 成功返回元素对象数组，失败返回null
  */
  async FindElementsByControlType(rootElement, controlType){
    let strData = this.setSendData('FindElementsByControlType', rootElement.v, controlType);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElements(strRet.split("\n"));
    }
    return null;
  }

  /**通过xpath查找元素
   * @param {Object} rootElement 根元素
   * @param {string} xpath 要查找元素的xpath值
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindElementByXpath(rootElement, xpath){
    let strData = this.setSendData('FindElementByXpath', rootElement.v, xpath);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return this.formatElement(strRet);
    }
    return null;
  }

  /**查找父元素
   * @param {Object} currentElement 当前元素
   * @param {boolean} isRelease 是否释放当前元素,currentElement不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindParentElement(currentElement, isRelease = true){
    let strData = this.setSendData('FindParentElement', currentElement.v, isRelease);
    if(isRelease)
      currentElement.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return this.formatElement(strRet);
  }

  /**查找下一个兄弟元素
   * @param {Object} currentElement 当前元素
   * @param {boolean} isRelease 是否释放当前元素,currentElement不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindNextSiblingElement(currentElement, isRelease = true){
    let strData = this.setSendData('FindNextSiblingElement', currentElement.v, isRelease);
    if(isRelease)
      currentElement.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return this.formatElement(strRet);
  }

  /**查找上一个兄弟元素
   * @param {Object} currentElement 当前元素
   * @param {boolean} isRelease 是否释放当前元素,currentElement不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindPreviousSiblingElement(currentElement, isRelease = true){
    let strData = this.setSendData('FindPreviousSiblingElement', currentElement.v, isRelease);
    if(isRelease)
      currentElement.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return this.formatElement(strRet);
  }

  /**查找第一个子元素
   * @param {Object} currentElement 当前元素
   * @param {boolean} isRelease 是否释放当前元素,currentElement不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindFirstChildElement(currentElement, isRelease = true){
    let strData = this.setSendData('FindFirstChildElement', currentElement.v, isRelease);
    if(isRelease)
      currentElement.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return this.formatElement(strRet);
  }

  /**查找最后一个子元素
   * @param {Object} currentElement 当前元素
   * @param {boolean} isRelease 是否释放当前元素,currentElement不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {Object} 成功返回元素对象，失败返回null
  */
  async FindLastChildElement(currentElement, isRelease = true){
    let strData = this.setSendData('FindLastChildElement', currentElement.v, isRelease);
    if(isRelease)
      currentElement.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return this.formatElement(strRet);
  }

  /**获取指定元素name属性值
   * @param {Object} element 指定元素
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {string} 成功返回元素name属性值
  */
  async GetElementName(element, isRelease = true){
    let strData = this.setSendData('GetElementName', element.v, isRelease);
    if(isRelease)
      element.v = 0;
    return await this.clientPipeServer(strData);
  }

  /**获取指定元素矩形大小
   * @param {Object} element 指定元素
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {{left:number, top:number, right:number, bottom:number}} 成功返回元素矩形大小,失败返回{left:-1, top:-1, right:-1, bottom:-1}
  */
  async GetElementBoundingRectangle(element, isRelease = true){
    let strData = this.setSendData('GetElementBoundingRectangle', element.v, isRelease);
    if(isRelease)
      element.v = 0;
    return JSON.parse(await this.clientPipeServer(strData));
  }

  /**获取指定元素ValueValue属性值
   * @param {Object} element 指定元素
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {string} 成功返回元素ValueValue属性值
  */
  async GetElementValueValue(element, isRelease = true){
    let strData = this.setSendData('GetElementValueValue', element.v, isRelease);
    if(isRelease)
      element.v = 0;
    return await this.clientPipeServer(strData);
  }

  /**获取指定元素ControlType属性值
   * @param {Object} element 指定元素
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {string} 成功返回元素ControlType属性值
  */
  async GetControlType(element, isRelease = true){
    let strData = this.setSendData('GetControlType', element.v, isRelease);
    if(isRelease)
      element.v = 0;
    return await this.clientPipeServer(strData);
  }

  /**设置指定元素value
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false
  */
  async SetElementValue(element, value, isRelease = true){
    let strData = this.setSendData('SetElementValue', element.v, value, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**通过元素窗口句柄设置指定元素value
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false.
  */
  async SetElementValueEx(element, value, isRelease = true){
    let strData = this.setSendData('SetElementValueEx', element.v, value, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**执行元素默认操作,一般用作点击
   * @param {Object} element 指定元素
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false.
  */
  async InvokeElement(element, isRelease = true){
    let strData = this.setSendData('InvokeElement', element.v, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**设置指定元素作为焦点
   * @param {Object} element 指定元素
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false.
  */
  async SetElementFocus(element, isRelease = true){
    let strData = this.setSendData('SetElementFocus', element.v, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**设置指定元素滚动条
   * @param {Object} element 指定元素
   * @param {number} horizontalPercent 水平百分比0.0-1.0,为-1时不滚动
   * @param {number} verticalPercent 垂直百分比0.0-1.0,为-1时不滚动
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false.
  */
  async SetElementScroll(element, horizontalPercent, verticalPercent, isRelease = true){
    let strData = this.setSendData('SetElementScroll', element.v, horizontalPercent, verticalPercent, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }
  /**通过元素窗口句柄点击控件
   * @param {Object} element 指定元素
   * @param {number} msg 单击左键:1 单击右键:2 按下左键:3 弹起左键:4 按下右键:5 弹起右键:6 双击左键:7 双击右键:8
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false.后台模式无法点击非客户端区域
  */
  async ClickElement(element, msg, isRelease = true){
    let strData = this.setSendData('ClickElement', element.v, msg, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**关闭指定元素窗口
   * @param {Object} element 指定元素
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false.
  */
  async CloseWindow(element, isRelease = true){
    let strData = this.setSendData('CloseWindow', element.v, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**设置指定元素窗口状态
   * @param {Object} element 指定元素
   * @param {number} state 正常:0 最大化:1 最小化:2
   * @param {boolean} isRelease 是否释放element,元素不再使用时必须释放,否则内存泄漏.默认为true释放当前元素
   * @return {boolean} 成功返回true,失败返回false.
  */
  async SetWindowState(element, state, isRelease = true){
    let strData = this.setSendData('SetWindowState', element.v, state, isRelease);
    if(isRelease)
      element.v = 0;
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**手动释放指定元素,windows元素操作必须要释放元素,否则内存泄漏
   * @param {Object} element 指定元素
   * @return {boolean} 总是返回true
  */
  async ReleaseElement(element){
    let strData = this.setSendData('ReleaseElement', element.v);
    element.v = 0;
    return await this.clientPipeServer(strData);
  }

  /**手动释放指定元素数组,元素数组不再使用时,必须调用此函数手动释放,否则大量内存泄漏
   * @param {Object[]} elements 指定元素数组
   * @return {boolean} 总是返回true
  */
  async ReleaseElements(elements){
    let strElements = '';
    for(let i = 0; i < elements.length; i++)
    {
      strElements += elements[i].v + '\n';
      elements[i].v = 0;
    }
    let strData = this.setSendData('ReleaseElements', strElements);
    return await this.clientPipeServer(strData);
  }

  /**打开内置浏览器WebBot
   * @param {string} url 网址
   * @return {boolean} 总是返回true
  */
  async openWebBot(url){
    let strData = this.setSendData('openWebBot', url);
    return await this.clientPipeServer(strData);
  }

  /**切换WebBot页面
   * @param {number} index 索引号,0为起首页
   * @return {boolean} 总是返回true
  */
  async switchPage(index){
    let strData = this.setSendData('switchPage', index);
    return await this.clientPipeServer(strData);
  }

  /**关闭WebBot页面
   * @param {number} index 索引号,0为起首页
   * @return {boolean} 总是返回true
  */
  async closePage(index){
    let strData = this.setSendData('closePage', index);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,通过id获取元素
   * @param {string} id 元素id值
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {Object} 成功返回元素对象,失败返回null
  */
  async getElementById(id, iframe = null){
    let strData = this.setSendData('getElementById', id, iframe);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet;
    }
    return null;
  }

  /**WebBot,通过class获取元素数组
   * @param {string} classNames 元素class值
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {Object[]} 成功返回元素对象数组,失败返回null
  */
  async getElementsByClassName(classNames, iframe = null){
    let strData = this.setSendData('getElementsByClassName', classNames, iframe);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet.split("\n");
    }
    return null;
  }

  /**WebBot,通过name获取元素数组
   * @param {string} classNames 元素name值
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {Object[]} 成功返回元素对象数组,失败返回null
  */
  async getElementsByName(elementName, iframe = null){
    let strData = this.setSendData('getElementsByName', elementName, iframe);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet.split("\n");
    }
    return null;
  }

  /**WebBot,通过tagName获取元素数组
   * @param {string} localName 元素tagName值
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {Object[]} 成功返回元素对象数组,失败返回null
  */
  async getElementsByTagName(localName, iframe = null){
    let strData = this.setSendData('getElementsByTagName', localName, iframe);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet.split("\n");
    }
    return null;
  }

  /**WebBot,通过xpath获取元素数组
   * @param {string} xpath 元素xpath路径
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {Object} 成功返回元素对象,失败返回null
  */
  async getElementByXpath(xpath, iframe = null){
    let strData = this.setSendData('getElementByXpath', xpath, iframe);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet;
    }
    return null;
  }

  /**WebBot,通过ccs selector获取元素
   * @param {string} selector 元素selector路径
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {Object} 成功返回元素对象,失败返回null
  */
  async querySelector(selector, iframe = null){
    let strData = this.setSendData('querySelector', selector, iframe);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet;
    }
    return null;
  }

  /**WebBot,通过ccs selector获取元素数组
   * @param {string} selectors 元素selector路径
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {Object[]} 成功返回元素对象数组,失败返回null
  */
  async querySelectorAll(selectors, iframe = null){
    let strData = this.setSendData('querySelectorAll', selectors, iframe);
    let strRet;
    for(let i = 0; i <= this.waitTimeout / this.intervalTimeout; i++){
      strRet = await this.clientPipeServer(strData);
      if(strRet == "null")
        await this.Sleep(this.intervalTimeout);
      else
        return strRet.split("\n");
    }
    return null;
  }

  /**WebBot,点击元素
   * @param {Object} element 要点击的元素
   * @return {boolean} 总是返回true
  */
  async clickElement(element){
    let strData = this.setSendData('clickElement', element);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,点击元素(windows api方式点击)
   * @param {Object} element 点击的元素
   * @param {Object} iframe 可选参数,元素所属的iframe
   * @return {boolean} 总是返回true
  */
  async clickElementEx(element, iframe = null){
    let strData = this.setSendData('clickElementEx', element, iframe);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,设置元素value
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @return {boolean} 总是返回true
  */
  async setValue(element, value){
    let strData = this.setSendData('setValue', element, value);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素value
   * @param {Object} element 指定元素
   * @return {string} 成功返回value值
  */
  async getValue(element){
    let strData = this.setSendData('getValue', element);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,设置元素textConten
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @return {boolean} 总是返回true
  */
  async setTextConten(element, value){
    let strData = this.setSendData('setTextConten', element, value);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素textConten
   * @param {Object} element 指定元素
   * @return {string} 成功返回textConten值
  */
  async getTextConten(element){
    let strData = this.setSendData('getTextConten', element);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,设置元素outerText
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @return {boolean} 总是返回true
  */
  async setOuterText(element, value){
    let strData = this.setSendData('setOuterText', element, value);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素outerText
   * @param {Object} element 指定元素
   * @return {string} 成功返回outerText值
  */
  async getOuterText(element){
    let strData = this.setSendData('getOuterText', element);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,设置元素outerHTML
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @return {boolean} 总是返回true
  */
  async setOuterHTML(element, value){
    let strData = this.setSendData('setOuterHTML', element, value);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素outerHTML
   * @param {Object} element 指定元素
   * @return {string} 成功返回outerHTML值
  */
  async getOuterHTML(element){
    let strData = this.setSendData('getOuterHTML', element);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,设置元素innerText
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @return {boolean} 总是返回true
  */
  async setInnerText(element, value){
    let strData = this.setSendData('setInnerText', element, value);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素innerText
   * @param {Object} element 指定元素
   * @return {string} 成功返回innerText值
  */
  async getInnerText(element){
    let strData = this.setSendData('getInnerText', element);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,设置元素innerHTML
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @return {boolean} 总是返回true
  */
  async setInnerHTML(element, value){
    let strData = this.setSendData('setInnerHTML', element, value);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素innerHTML
   * @param {Object} element 指定元素
   * @return {string} 成功返回innerHTML值
  */
  async getInnerHTML(element){
    let strData = this.setSendData('getInnerHTML', element);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,设置元素属性
   * @param {Object} element 指定元素
   * @param {string} value 设置的值
   * @param {string} name 属性名称
   * @return {boolean} 总是返回true
  */
  async setAttribute(element, value, name){
    let strData = this.setSendData('setAttribute', element, value, name);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素属性值
   * @param {Object} element 指定元素
   * @param {string} name 属性名称
   * @return {string} 成功返回name对应的属性值
  */
  async getAttribute(element, name){
    let strData = this.setSendData('getAttribute', element, name);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,选择下拉框值
   * @param {Object} element 设指定元素
   * @param {string} checkValue 选中的值
   * @return {boolean} 总是返回true
  */
  async setSelect(element, checkValue){
    let strData = this.setSendData('setSelect', element, checkValue);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,获取元素矩形大小
   * @param {Object} element 指定元素
   * @return {{left:number, top:number, right:number, bottom:number, width:number, height:number}} 成功返矩形大小
  */
  async getBoundingClientRect(element){
    let strData = this.setSendData('getBoundingClientRect', element);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return this.formatRect(strRet);
  }

  /**WebBot,注入JavaScript代码在v8执行
   * @param {string} scriptCode JavaScript代码
   * @return {boolean} 总是返回true
  */
  async executeScript(scriptCode){
    let strData = this.setSendData('executeScript', scriptCode);
    return await this.clientPipeServer(strData);
  }

  /**WebBot,node与V8共享数据。WebBot V8有同名称扩展函数，可在executeScript调用。shareData更新需要10-100毫秒
   * @param {string} shareData 设置共享数据值,可选参数
   * @return {string} 返回node/v8 设置的shareData值。
  */
  async nodePipeScript(shareData = 'null'){
    let strData = this.setSendData('nodePipeScript', shareData);
    return await this.clientPipeServer(strData);
  }

  /**初始化百度ocr
   * @param {string} appId 百度ocr提供
   * @param {string} apiKey 百度ocr提供
   * @param {string} secretKey 百度ocr提供
   * @return {void} 返回值为空
  */
  async InitOcr(appId, apiKey, secretKey){
    await ocr.InitOcr(appId, apiKey, secretKey);
  }

  /**百度ocr获取图片上的文字
   * @param {string} imagePath 图片路径
   * @param {number} ocrType 识别类型,通用文字识别:1 高精度版:2 网络图片文字识别:3 数字识别:4 手写文字识别:5 二维码识别:6
   * @return {string} 成功返回获取的文字
  */
  async GetImageWords(imagePath, ocrType){
    return await ocr.GetImageWords(imagePath, ocrType);
  }

  /**百度ocr获取图片文字坐标
   * @param {number} hwnd 图片所属窗口的句柄,手机图片识别一般为null
   * @param {string} imagePath 图片路径
   * @param {string} words 识别的文字
   * @param {number} index 文字出现的次数,默认为0,查找第一次出现的坐标
   * @return {{x:number, y:number}} 成功返回文字坐标,失败返回{x:-1, y:-1}
  */
  async FindImageWords(hwnd, imagePath, words, index = 0){
    let point = await ocr.FindImageWords(imagePath, words, index);
    let strData = this.setSendData('ImagePointTransform', hwnd, point.x, point.y);
    return JSON.parse(await this.clientPipeServer(strData));
  }

  /**初始化验证码识别
   * @param {string} userName 用户名,第三方平台提供
   * @param {string} passWord 用户密码,第三方平台提供
   * @return {boolean} 总是返回true
  */
  async InitCheckCode(userName, passWord){
    let strData = this.setSendData('InitCheckCode', userName, passWord);
    return await this.clientPipeServer(strData);
  }

  /**获取验证码
   * @param {string} imagePath 验证码图片路径
   * @param {number} codeType 验证码类型,参考第三方平台
   * @return {string} 成功返回验证码,失败返回错误信息
  */
  async GetCheckCode(imagePath, codeType){
    let strData = this.setSendData('GetCheckCode', imagePath, codeType);
    let strRet = await this.clientPipeServer(strData);
    let jsonRet = JSON.parse(strRet);
    this.captchaId = jsonRet['data']['captchaId'];//存放错误提交编号
    if(jsonRet['code'] == 0)
      return jsonRet['data']['recognition'];
    else
      return jsonRet['message'];
  }

  /**发送验证码识出错编号
   * @return {string} 成功返回"true",失败返回错误信息
  */
  async SendErrorCode(){
    let strData = this.setSendData('SendErrorCode', this.captchaId);
    let strRet = await this.clientPipeServer(strData);
    let jsonRet = JSON.parse(strRet);
    if(jsonRet['code'] == 0)
      return jsonRet['data']['result'];
    else
      return jsonRet['message'];
  }

  /**创建word文档
   * @param {Object} options Word文档格式，可选参数，options列表:
   * type（字符串）'docx' 必要参数值
   * author（字符串）-文档的作者
   * creator（字符串）-别名。文档的作者
   * description'（字符串）-文档的属性注释
   * keywords（字符串）-文档的关键字
   * orientation（字符串）-横向'landscape'或纵向'portrait'。默认值为'portrait'
   * pageMargins（对象）-设置文档页边距。默认值为{top: 1800, right: 1440, bottom: 1800, left: 1440}
   * pageSize（字符串|对象）-设置文档页面大小。默认值为A4（支持值：'A4', 'A3', 'letter paper'）。或使用{width: 11906, height: 16838}设置自定义尺寸
   * subject （字符串）-文档的主题
   * title（字符串）-文档的标题
   * columns（整型）-每页中的列数。默认值为1列。
   * @return {Object} word对象
  */
  async wordCreate(options = {type: 'docx'}){
    return officegen(options);
  }

  /**添加word分页
   * @param {Object} docxObject word对象
   * @return {void} 
  */
  async wordAddPage(docxObject){
    docxObject.putPageBreak();
  }

  /**创建表格
   * @param {Object} docxObject word对象
   * @param {Object} table 表格
   * @param {Object} tableStyle 表格样式
   * @return {void} 
  */
  async wordCreateTable(docxObject, table, tableStyle){
    docxObject.createTable(table, tableStyle);
  }

  /**添加页眉
   * @param {Object} docxObject word对象
   * @param {string} text 要添加的文本
   * @param {string} options 可选参数，要更改的页面 'even'-更改偶数页。'first'-仅更改首页
   * @return {void} 
  */
  async wordAddHeader(docxObject, text, options = ''){
    let header = docxObject.getHeader(options).createP();
    header.addText(text);
  }

  /**添加页脚
   * @param {Object} docxObject word对象
   * @param {string} text 要添加的文本
   * @param {string} options 可选参数，要更改的页面 'even'-更改偶数页。'first'-仅更改首页
   * @return {void} 
  */
  async wordAddFooter(docxObject, text, options = ''){
    let footer = docxObject.getFooter(options).createP();
    footer.addText(text);
  }

  /**创建无作序号的段落
   * @param {Object} docxObject word对象
   * @param {Object} options 可选参数，段落格式，options列表:
   * align（字符串）-水平对齐，可以是'left'（默认），'right'，'center'或'justify'
   * textAlignment（字符串）-垂直对齐方式，'center', 'top', 'bottom'或'baseline'
   * indentLeft（数字）- 向左缩进
   * indentFirstLine（数字）- 缩进第一行
   * backline（字符串）-颜色代码，例如：'ffffff'（白色）或'000000'黑色）
   * @return {Object} 段落对象
  */
  async wordCreateListOfDots(docxObject, options = {align: 'left'}){
    return docxObject.createListOfDots(options);
  }

  /**创建有序号数字的段落
   * @param {Object} docxObject word对象
   * @param {Object} options 可选参数，段落格式，options列表:
   * level (数字) 序号级别0 1 2 3...
   * align（字符串）-水平对齐，可以是'left'（默认），'right'，'center'或'justify'
   * textAlignment（字符串）-垂直对齐方式，'center', 'top', 'bottom'或'baseline'
   * indentLeft（数字）- 向左缩进
   * indentFirstLine（数字）- 缩进第一行
   * backline（字符串）-颜色代码，例如：'ffffff'（白色）或'000000'黑色）
   * @return {Object} 段落对象
  */
  async wordCreateListOfNumbers(docxObject, options = {align: 'left'}){
    return docxObject.createListOfNumbers(options);
  }

  /**创建有等级的无序号段落
   * @param {Object} docxObject word对象
   * @param {Object} options 可选参数，段落格式，options列表:
   * level (数字) 序号级别0 1 2 3...
   * align（字符串）-水平对齐，可以是'left'（默认），'right'，'center'或'justify'
   * textAlignment（字符串）-垂直对齐方式，'center', 'top', 'bottom'或'baseline'
   * indentLeft（数字）- 向左缩进
   * indentFirstLine（数字）- 缩进第一行
   * backline（字符串）-颜色代码，例如：'ffffff'（白色）或'000000'黑色）
   * @return {Object} 段落对象
  */
  async wordCreateNestedUnOrderedList(docxObject, options = {"level":2}){
    return docxObject.createNestedUnOrderedList(options);
  }

  /**创建有等级的序号段落
   * @param {Object} docxObject word对象
   * @param {Object} options 可选参数，段落格式，options列表:
   * align（字符串）-水平对齐，可以是'left'（默认），'right'，'center'或'justify'
   * textAlignment（字符串）-垂直对齐方式，'center', 'top', 'bottom'或'baseline'
   * indentLeft（数字）- 向左缩进
   * indentFirstLine（数字）- 缩进第一行
   * backline（字符串）-颜色代码，例如：'ffffff'（白色）或'000000'黑色）
   * @return {Object} 段落对象
  */
  async wordCreateNestedOrderedList(docxObject, options = {"level":2}){
    return docxObject.createNestedOrderedList(options);
  }

  /**创建段落
   * @param {Object} docxObject word对象
   * @param {Object} options 可选参数，段落格式，options列表:
   * align（字符串）-水平对齐，可以是'left'（默认），'right'，'center'或'justify'
   * textAlignment（字符串）-垂直对齐方式，'center', 'top', 'bottom'或'baseline'
   * indentLeft（数字）- 向左缩进
   * indentFirstLine（数字）- 缩进第一行
   * backline（字符串）-颜色代码，例如：'ffffff'（白色）或'000000'黑色）
   * @return {Object} 段落对象
  */
  async wordCreateParagraph(docxObject, options = {align: 'left'}){
    return docxObject.createP(options);
  }

  /**将文本添加到段落
   * @param {Object} paragraphObject 段落对象
   * @param {string} text 要添加的文本
   * @param {Object} sytle 可选参数，文本样式，sytle列表:
   * back（字符串）-背景颜色代码，例如：'ffffff'（白色）或'000000'黑色）
   * shdType（字符串）-要使用的可选模式代码：'clear'（无模式），'pct10'，'pct12'，'pct15'，'diagCross'，'diagStripe'，'horzCross'，'horzStripe'，'nil' ，'thinDiagCross'，'solid'等
   * shdColor（字符串）-模式的前部颜色（与shdType一起使用）
   * bold（布尔）-为true时文本变为粗体
   * border（字符串）-边框类型：'single'，'dashDotStroked'，'dashed'，'dashSmallGap'，'dotDash'，'dotDotDash'，'dotted'，'double'，'thick'
   * color（字符串）-字体颜色代码，例如：“ ffffff”（白色）或“ 000000”（黑色）
   * italic（布尔值）-设置为斜体时为true
   * underline（布尔值）-为true表示要添加下划线
   * font_face（字符串）-要使用的字体,例如：'Arial'
   * font_face_east（字符串）-高级设置：用于东亚的字体。您还必须设置font_face
   * font_face_cs（字符串）-高级设置：要使用的字体（cs）。您还必须设置font_face
   * font_face_h（字符串）-高级设置：要使用的字体（hAnsi）。您还必须设置font_face
   * font_hint（字符串）-可选。'ascii'（默认），'eastAsia'，'cs'或'hAnsi'
   * font_size（数字）-以磅为单位的字体大小
   * rtl（布尔值）-将其添加到rtl语言的任何文本中
   * highlight (字符串) - 高亮颜色。'black', 'blue', 'cyan', 'darkBlue', 'darkCyan', 'darkGray', 'darkGreen', 'darkMagenta', 'darkRed', 'darkYellow', 'green', 'lightGray', 'magenta', 'none', 'red', 'white'，'yellow'
   * strikethrough（布尔值）-添加删除线时为true。
   * superscript（布尔值）-如果可以使用较小的尺寸，则为true可以将此次运行中的文本降低到基线以下，并将其更改为较小的尺寸。
   * subscript（布尔值）-为true时，如果可以使用较小的尺寸，则将运行中的文本升高到基线以上，并将其更改为较小的尺寸
   * link（字符串）-超连接
   * hyperlink（字符串）向书签的超链接
   * @return {void} 
  */
  async wordAddText(paragraphObject, text, sytle = {}){
    paragraphObject.addText(text, sytle);
  }

  /**将图像添加到段落
   * @param {Object} paragraphObject 段落对象
   * @param {string} imagePath 图片路径
   * @param {Object} area 可选参数, 图片宽高 {cx: 300, cy: 200}
   * @return {void} 
  */
  async wordAddImage(paragraphObject, imagePath, area = {}){
    paragraphObject.addImage(imagePath, area);
  }

  /**段落换行
   * @param {Object} paragraphObject 段落对象
   * @return {void} 
  */
  async wordBreak(paragraphObject){
    paragraphObject.addLineBreak();
  }

  /**添加一条水平线,看上去与换行相似？
   * @param {Object} paragraphObject 段落对象
   * @return {void} 
  */
  async wordAddHorizontalLine(paragraphObject){
    paragraphObject.addHorizontalLine();
  }

  /**添加书签
   * @param {Object} paragraphObject 段落对象
   * @param {string} markName 标签名
   * @return {void} 
  */
  async wordStartBookmark(paragraphObject, markName){
    paragraphObject.startBookmark (markName);
  }

  /**书签结束位置
   * @param {Object} paragraphObject 段落对象
   * @return {void} 
  */
  async wordEndBookmark(paragraphObject){
    paragraphObject.endBookmark();
  }

  /**保存word文件
   * @param {Object} docxObject word对象
   * @param {string} filePath 保存的路径
   * @return {void} 
  */
  async wordSave(docxObject, filePath){
    let out = fs.createWriteStream(filePath)
    docxObject.generate(out);
  }

  /**读取word内容
   * @param {string} filePath 文件路径，仅支持docx格式, doc可以直接改为docx格式
   * @return {string}  成功返回读取到的内容，失败返回null
  */
  async wordReadText(filePath){
    return new Promise((resolve) => {
      textract.fromFileWithPath(filePath, (error, text) =>{
        if(error)
          resolve(null);
        else
          resolve(text);
      })
    })
  }

  /**打开excel文档
   * @param {string} excelPath excle路径
   * @return {Object} 成功返回excel对象，失败返回null
  */
  async OpenExcel(excelPath){
    let strData = this.setSendData('OpenExcel', excelPath);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return JSON.parse(strRet);
  }

  /**打开excel表格
   * @param {Object} excelObject excel对象
   * @param {string} sheetName 表名
   * @return {Object} 成功返回sheet对象，失败返回null
  */
  async OpenExcelSheet(excelObject, sheetName){
    let strData = this.setSendData('OpenExcelSheet', excelObject['book'], excelObject['path'], sheetName);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return strRet;
  }

  /**保存excel文档
   * @param {Object} excelObject excel对象
   * @return {boolean} 成功返回true，失败返回false
  */
  async SaveExcel(excelObject){
    let strData = this.setSendData('SaveExcel', excelObject['book'], excelObject['path']);
    return await this.clientPipeServer(strData);
  }

  /**写入数字到excel表格
   * @param {Object} sheetObject sheet对象
   * @param {number} row 行
   * @param {number} col 列
   * @param {number} value 写入的值
   * @return {boolean} 成功返回true，失败返回false
  */
  async WriteExcelNum(sheetObject, row, col, value){
    let strData = this.setSendData('WriteExcelNum', sheetObject, row, col, value);
    return await this.clientPipeServer(strData);
  }

  /**写入字符串到excel表格
   * @param {Object} sheetObject sheet对象
   * @param {number} row 行
   * @param {number} col 列
   * @param {string} strValue 写入的值
   * @return {boolean} 成功返回true，失败返回false
  */
  async WriteExcelStr(sheetObject, row, col, strValue){
    let strData = this.setSendData('WriteExcelStr', sheetObject, row, col, strValue);
    return await this.clientPipeServer(strData);
  }

  /**读取excel表格数字
   * @param {Object} sheetObject sheet对象
   * @param {number} row 行
   * @param {number} col 列
   * @return {number} 返回读取到的数字
  */
  async ReadExcelNum(sheetObject, row, col){
    let strData = this.setSendData('ReadExcelNum', sheetObject, row, col);
    let strRet = await this.clientPipeServer(strData);
    return parseFloat(strRet);
  }

  /**读取excel表格字串
   * @param {Object} sheetObject sheet对象
   * @param {number} row 行
   * @param {number} col 列
   * @return {string} 返回读取到的字符
  */
  async ReadExcelStr(sheetObject, row, col){
    let strData = this.setSendData('ReadExcelStr', sheetObject, row, col);
    let strRet = await this.clientPipeServer(strData);
    return strRet;
  }

  /**发送邮件
   * @param {string} smtpServer  SMTP服务地址
   * @param {number} smtpPort SMTP服务端号
   * @param {string} authCode 第三方邮箱平台授权码
   * @param {string} sendMailer 发送人邮箱
   * @param {string} sendName 发送人名称
   * @param {string} recvMailer 接收人邮箱,多人逗号分开
   * @param {string} subject 邮箱主题
   * @param {string} text 发送的正文 文本格式
   * @param {string} html 发送的正文 html格式，可选参数，默认为null
   * @param {Object[]} attachments 发送的附件,可选参数，默认为null 示例：
   * * let attachments = [
          {   // utf-8字符串作为附件
              filename: 'text1.txt',
              content: 'hello world!'
          },
          {   //磁盘上的文件作为附件
              filename: 'text3.txt',
              path: '/path/to/file.txt'
          },
          {   //文件名和内容类型是从路径生成
              path: '/path/to/file.txt'
          },
          {   //使用URL作为附件
              filename: 'WindowsDoc.pdf',
              path: 'http://www.aibot.net/WindowsDoc.pdf'
          }
      ]
  * @return {string} 成功返回"邮件发送成功!"，失败返回错误信息
  */
  async SendMail(smtpServer, smtpPort, authCode, sendMailer, sendName, recvMailer, subject, text, html = null, attachments = null){
    //组建发送人
    sendName += " <" + sendMailer +">";
    //smtpPort为465时 secure为true，否则 false
    let is465 = false;
    if(smtpPort == 465)
        is465 = true;
    let transporter = nodemailer.createTransport({
        host: smtpServer,
        port: smtpPort,
        secure: is465,
        auth: {
          user: sendMailer,
          pass: authCode,
        },
      });

    try{
      await transporter.sendMail({
          from: sendName,
          to: recvMailer,
          subject: subject,
          text: text,
          html: html,
          attachments:attachments,
        });
        return "邮件发送成功!";
    }catch(error){
        return error;
    }
  }

  /**获取邮件
   * @param {string} imapServer  IMAP服务地址
   * @param {number} imapPort IMAP服务端号
   * @param {string} authCode 第三方邮箱平台授权码
   * @param {string} mailAccount 邮箱账号
   * @param {string} criteria 获取哪类邮件，所有邮件'ALL' 未读邮件'UNSEEN' 已读邮件'SEEN' 第1-3封'1:3'
   * @return {Object} 成功返回邮件信息对象，失败返回错误信息
  */
  async GetMail(imapServer, imapPort, authCode, mailAccount,criteria){
    return new Promise((resolve) => {
      let retData = [];
      let imap = new Imap({
        user: mailAccount,
        password: authCode,
        host: imapServer,
        port: imapPort,
        tls: true,
        //authTimeout:3000,
        tlsOptions: { rejectUnauthorized: false }
      });

      function openInbox(cb) {
        imap.openBox('INBOX', false, cb);
      }
    
      imap.connect();
      
      imap.once('ready', function() {
        openInbox(function() {
            imap.search([criteria], function(err, results) {
              imap.setFlags(results, ['\\Seen']);
              let f = imap.fetch(results, { bodies: ''});
              f.on('message', function(msg, seqno) {
                let mailparser = new MailParser();
                msg.on('body', function(stream) {
                  stream.pipe(mailparser);
                  retData[seqno] = {};
                  mailparser.on("headers", function(headers) {
                    retData[seqno]["from"] = headers.get('from').text;
                    retData[seqno]["to"] = headers.get('to').text;
                    retData[seqno]["date"] = headers.get('date');
                    retData[seqno]["subject"] = headers.get('subject');
                  });

                  mailparser.on("data", function(data) {
                      if (data.type === 'text')
                        retData[seqno]["text"] = data.text;
                      else if(data.type === 'html')
                        retData[seqno]["text"] = data.html;
                      else if(data.type === 'textAsHtml ')
                        retData[seqno]["text"] = data.textAsHtml;
                      else if (data.type === 'attachment') {
                          data.content.pipe(fs.createWriteStream(data.filename));
                          data.release();
                      }
                  });
                });

              f.once('end', function() {
                  imap.end();
              });
            });
          });
        });
      })

      imap.once('close', function() {
        for(let i = 0; i < retData.length; i++){
          if(retData[i] == null){
            retData.splice(i,1);
            i--;
          }
        }
        resolve(retData);
      });
    })
  }

  /**Pdf转换图片
   * @param {string} pdfPath  pdf路径
   * @param {number} quality 图片品质，可选参数，默认100
   * @return {boolean} 成功返回true, 失败返回false。图片生成在当前目录下，以pdf文件命名，多页Pdf会生成多个图片
  */
  async PdfToImage(pdfPath, quality = 100){
    pdf2png.ghostscriptPath = "WindowsBot\\Pdf2Png\\executables\\ghostScript";
    await pdf2png.convert(pdfPath, {quality:quality}, async function(resp){
      if(!resp.success){
        console.log(resp.error);
        return false;
      }

      let imagePath = pdfPath.substring(0, pdfPath.length-4) + resp.imgNum + ".png";
      await fs.writeFile(imagePath, resp.data, function(err) {
      if(err)
        console.log(err);
      });
    });
    return true;
  }

  /**导出cookie
   * @param {string} filePath cookie文件路径
   * @param {string} url 域名格式：http://www.aibot.net
   * @return {boolean} 成功返回true,失败返回false
  */
  async ExportCookie(filePath, url){
      let strData = this.setSendData('ExportCookie', filePath, url);
      let strRet = await this.clientPipeServer(strData);
      if(strRet == "false")
        return false;
      else
        return true;
  }

  /**导入cookie
   * @param {string} filePath cookie文件路径
   * @param {string} url 域名格式：http://www.aibot.net
   * @return {boolean} 成功返回true,失败返回false
  */
  async ImportCookie(filePath, url){
    let strData = this.setSendData('ImportCookie', filePath, url);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**清除WebBot cookie, 不会删除本地cookie文件
   * @param {string} filePath cookie文件路径
   * @param {string} url 域名格式：http://www.aibot.net
   * @return {boolean} 成功返回true,失败返回false
  */
  async ClearCookie(filePath, url){
    let strData = this.setSendData('ClearCookie', filePath, url);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**获取主板识别码，一般用作脚本授权
   * @return {string} 成功返回BoisId,失败返回null
  */
  async GetBoisId(){
    let strData = this.setSendData('GetBoisId');
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "null")
      return null;
    else
      return strRet;
  }

  async GetToken(keyId, keySecret){
    let strData = this.setSendData('GetToken', keyId, keySecret);
    let strRet = await this.clientPipeServer(strData);
    return strRet;
  }

  async waitLoop4Complete(saveFile, urlValue, appkeyValue, tokenValue, task_id_value, request_id_value, resolve) {
    let fullUrl = urlValue + "?appkey=" + appkeyValue + "&task_id=" + task_id_value + "&token=" + tokenValue + "&request_id=" + request_id_value;
    let thisBot = this;
    let timer = setInterval(() => {
        let options = {
            url: fullUrl,
            method: 'GET'
        };
        request(options, function (error, response, body) {
            if (error != null) {
                console.log(error);
                resolve(false);
                return ;
            } else if(response.statusCode != 200) {
                console.log("Http Request Fail: " + response.statusCode + "; " + body.toString());
                resolve(false);
                return ;
            } else {
                let code = 0;
                let audio_address= null;
                let json = JSON.parse(body.toString());
                for(let key in json){  
                    if(key=='error_code')
                        code = json[key]
                    else if(key == "data" && json["data"] != null)
                        audio_address = json[key]["audio_address"];
                }
                if(code == 20000000 && audio_address == null)
                    console.info("正在合成语音，请稍等...");
                else if(code == 20000000 && audio_address != "") {
                    clearInterval(timer);
                    thisBot.DownloadFile(audio_address, saveFile, true);
                    resolve(true);
                    return ;
                } 
                else{
                    resolve(false);
                    return ;
                }
            }
        });
    }, 10000);
  }

  /**语音合成, 支持一次性合成300字符以内的文字，超过300个字符的内容会被截断。
 * @param {string} saveFile     音频保存文件路径
 * @param {string} appkey       appkey
 * @param {string} keyId        accessKeyId
 * @param {string} keySecret    accessKeySecret
 * @param {string} text         待合成的文本，需要为UTF-8编码，支持SSML，例如：<speak>我<break time="2000ms"/>停顿了两秒</speak>  time范围[50, 10000]的整数。
 * @param {string} voice        发音人，可选参数，默认"ruoxi"。支持以下音种：
 *                                  ruoxi(温柔女声) siqi(温柔女声) sijia(标准女声) sicheng(标准男声)ninger(标准女声) ruilin(标准女声)
 *                                  siyue(温柔女声) xiaomei(甜美女声) yina(浙普女声) sijing(严厉女声)sitong(儿童音) xiaobei(萝莉女声) 
 *                                  wendy(英音女声) william(英音男声) olivia(英音女声) shanshan(粤语女声)
 * @param {JSON} ttsArgs        tts参数, 可选，默认值为：
 * {"format":"wav", "sampleRate":24000, "volume":50, "speechRate":0, "pitchRate":0}
 * "format"：音频编码格式，支持pcm/wav/mp3格式，默认"wav"。
 * "sampleRate"：音频采样率，支持24000/16000/8000(Hz)，默认24000。
 * "volume"：音量，范围是0~100，默认50。
 * "speechRate"：语速，范围是-500~500，默认是0。
 * "pitchRate"：语调，范围是-500~500，默认是0。
 * @return {boolean}
*/
async Tts(saveFile, appkey, keyId, keySecret, text, voice = "ruoxi",ttsArgs) {
  let format = 'wav', sampleRate = 24000, volume = 50, speechRate = 0, pitchRate = 0;
  if(ttsArgs['format'] != undefined) format = ttsArgs['format'];
  if(ttsArgs['sampleRate'] != undefined) sampleRate = ttsArgs['sampleRate'];
  if(ttsArgs['volume'] != undefined) volume = ttsArgs['volume'];
  if(ttsArgs['speechRate'] != undefined) speechRate = ttsArgs['speechRate'];
  if(ttsArgs['pitchRate'] != undefined) pitchRate = ttsArgs['pitchRate'];

  let textUrlEncode = encodeURIComponent(text)
                  .replace(/[!'()*]/g, function(c) {
                      return '%' + c.charCodeAt(0).toString(16);
                  });
  let token = await this.GetToken(keyId, keySecret);
  
  let url = 'https://nls-gateway.cn-shanghai.aliyuncs.com/stream/v1/tts';
  url +='?appkey=' + appkey;
  url +='&token=' + token;
  url +='&text=' + textUrlEncode;
  url +='&format=' + format;
  url +='&sample_rate=' + sampleRate;
  url += '&voice=' + voice;
  url += "&volume=" + volume;
  url += "&speech_rate=" + speechRate;
  url += "&pitch_rate=" + pitchRate;
  let options = {
      url: url,
      method: 'GET',
      encoding: null
  };
  return new Promise((resolve) => {
      request(options, function (error, response, body) {
          if (error != null) {
              console.log(error);
              resolve(false);
              return ;
          }
          else {
              let contentType = response.headers['content-type'];
              if (contentType === undefined || contentType != 'audio/mpeg') {
                  console.log(body.toString());
                  resolve(false);
                  return ;
              }
              else {
                  fs.writeFileSync(saveFile, body);
                  resolve(true);
                  return ;
              }
          }
      });
    });
  }

  /**长文语音合成
 * @param {string} saveFile     音频保存文件路径
 * @param {string} appkey       appkey
 * @param {string} keyId        accessKeyId
 * @param {string} keySecret    accessKeySecret
 * @param {string} text         待合成的文本，需要为UTF-8编码，支持SSML，例如：<speak>我<break time="2000ms"/>停顿了两秒</speak> time范围[50, 10000]的整数。
 * @param {string} voice        发音人，可选参数，默认"zhiqi"。支持以下音种：
 *                              超高清场景
 *                                  zhiqi(温柔女声) zhichu(舌尖男声) zhixiang(磁性男声) zhijia(标准女声) zhinan(广告男声) 
 *                                  zhiqian(资讯女声) zhiru(新闻女声) zhide(新闻男声) zhifei(激昂解说) zhilun(悬疑解说) 
 *                                  zhiwei(萝莉女声) 
 *                              文学场景
 *                                  aiyuan(知心姐姐) aiying(软萌童声) aixiang(磁性男声) aimo(情感男声) aiye(青年男声)
 *                                  aiting(电台女声) aifan(情感女声) aide(新闻男声) ainan(广告男声) aihao(资讯男声)
 *                                  aiming(诙谐男声) aixiao(资讯女声) aichu(舌尖男声) aiqian(资讯女声) aishu(资讯男声)
 *                                  airu(新闻女声)   除以上值外，还支持语音合成所有的发音人
 * @param {JSON} ttsArgs        tts参数, 可选，默认值为：
 * {"format":"wav", "sampleRate":48000, "volume":50, "speechRate":0, "pitchRate":0}
 * "format"：音频编码格式，支持pcm/wav/mp3格式，默认"wav"。
 * "sampleRate"：音频采样率，支持48000/24000/16000/8000(Hz)，默认48000。
 * "volume"：音量，范围是0~100，默认50。
 * "speechRate"：语速，范围是-500~500，默认是0。
 * "pitchRate"：语调，范围是-500~500，默认是0。
 * @return {boolean}
*/
async LongTts(saveFile, appkey, keyId, keySecret, text, voice = "zhiqi", ttsArgs) {
  let format = 'wav', sampleRate = 48000, volume = 50, speechRate = 0, pitchRate = 0;
  if(ttsArgs['format'] != undefined) format = ttsArgs['format'];
  if(ttsArgs['sampleRate'] != undefined) sampleRate = ttsArgs['sampleRate'];
  if(ttsArgs['volume'] != undefined) volume = ttsArgs['volume'];
  if(ttsArgs['speechRate'] != undefined) speechRate = ttsArgs['speechRate'];
  if(ttsArgs['pitchRate'] != undefined) pitchRate = ttsArgs['pitchRate'];

  let token = await this.GetToken(keyId, keySecret);
  let url = "https://nls-gateway.cn-shanghai.aliyuncs.com/rest/v1/tts/async"
  let context = {
      device_id : "device_id",
  };
  let header = {
      appkey : appkey,
      token : token,
  };
  let tts_request = {
      "text" : text,
      "voice" : voice,
      "format" : format,
      "sample_rate" : sampleRate,
      "volume" : volume,
      "speech_rate" : speechRate,
      "pitch_rate" : pitchRate,
  };
  let payload = {
      "enable_notify" : false,
      "notify_url": "http://123.com",
      "tts_request" : tts_request,
  };
  let tts_body = {
      "context" : context,
      "header" : header,
      "payload" : payload
  };
  let bodyContent = JSON.stringify(tts_body);
  let httpHeaders = {'Content-type' : 'application/json'};

  let options = {
      url: url,
      method: 'POST',
      headers: httpHeaders,
      body: bodyContent,
      encoding: null
  };
  return new Promise((resolve) => {
      let thisBot = this;
      request(options, function (error, response, body) {
          if (error != null) {
              console.log(error);
              resolve(false);
              return ;
          } else {
              if(response.statusCode != 200) {
                  console.log("Http Request Fail: " + response.statusCode + "; " + body.toString());
                  resolve(false);
                  return;
              }
              let code = 0;
              let task_id = "";
              let request_id = "";
              let json = JSON.parse(body.toString());
              for(let key in json){  
                  if(key=='error_code')
                      code = json[key]
                  else if(key=='request_id')
                      request_id = json[key]
                  else if(key == "data")
                      task_id = json[key]["task_id"];
              }
              if(code == 20000000) {
                thisBot.waitLoop4Complete(saveFile, url, appkey, token, task_id, request_id, resolve);
              } else {
                  console.info("Request Error: status=" + $data["status"] + "; error_code=" + $data["error_code"] + "; error_message=" + $data["error_message"]);
                  resolve(false);
                  return ;
              }
          }
      });
    });
  }

  /**语音转文字**/
  async putOosFile(keyId, keySecret, fileName, filePath){
    let client = new OSS({
        region: 'oss-cn-hangzhou',
        accessKeyId: keyId,
        accessKeySecret: keySecret,
        bucket: 'aibot',
    });

  try{
        let result = await client.put(fileName, path.normalize(filePath));
        return result.url;
    } catch (e) {
        console.log(e);
        return false;
    }
  }

  async deleteOosFile (keyId, keySecret, fileName) {
      let client = new OSS({
          region: 'oss-cn-hangzhou',
          accessKeyId: keyId,
          accessKeySecret: keySecret,
          bucket: 'aibot',
      });

      try {
          await client.delete(fileName);
          return true;
      } catch (e) {
          return false;
      }
  }

  /**语音识别转换文字
   * @param {string} filePath     要识别的音频文件，支持 .wav、.mp3、.m4a、.wma、.aac、.ogg、.amr、.flac格式
   * @param {string} appkey       appkey
   * @param {string} keyId        accessKeyId
   * @param {string} keySecret    accessKeySecret
   * @return {boolean | string}   成功返回识别到的文字，失败返回false
  */
  async voiceTrans(filePath, appKey, keyId, keySecret) {
    let fileName = Date.now() + path.extname(filePath);
    let fileLink = await this.putOosFile(keyId, keySecret, fileName, filePath);
    if(!fileLink)
        return false;

    let retText = "";
    let ENDPOINT = 'http://filetrans.cn-shanghai.aliyuncs.com';
    let API_VERSION = '2018-08-17';
    let client = new Client({
        accessKeyId: keyId,
        secretAccessKey: keySecret,
        endpoint: ENDPOINT,
        apiVersion: API_VERSION
    });
    let task = {
        appkey : appKey,
        file_link : fileLink,
        version : "4.0",
        enable_sample_rate_adaptive: true,
        first_channel_only:true
    };
    task = JSON.stringify(task);
    let taskParams = {Task : task};
    let options = {method: 'POST'};

    return new Promise((resolve) => {
        client.submitTask(taskParams, options).then((response) => {
            let statusText = response.StatusText;
            if (statusText != 'SUCCESS'){
                console.log('error:' + statusText);
                resolve(false);
            }

            let taskId = response.TaskId;
            let taskIdParams = {TaskId : taskId};
            let timer = setInterval(() => {
              client.getTaskResult(taskIdParams).then((response) => {
                let statusText = response.StatusText;
                if (statusText == 'RUNNING' || statusText == 'QUEUEING') {
                    console.log("正在识别语音，请稍等...");
                }
                else {
                    if (statusText == 'SUCCESS' || statusText == 'SUCCESS_WITH_NO_VALID_FRAGMENT') {
                        var sentences = response.Result.Sentences;
                        for(let i in sentences)
                            retText += sentences[i].Text;

                        resolve(retText);
                        this.deleteOosFile(keyId, keySecret, fileName);
                    }
                    else {
                        console.log('error:' + statusText);
                        resolve(false);
                    }
                    clearInterval(timer);
                }
            }).catch((error) => {
                console.log(error);
                resolve(false);
                clearInterval(timer);
            });
          }, 10000);
        }).catch((error) => {
            console.log(error);
            resolve(false);
        });
    });
  }

  /**客户端坐标转换屏幕坐标(忽略标题栏的高度)
   * @param {number} hwnd 窗口句柄
   * @param {number} x  x坐标
   * @param {number} y  y坐标
   * @return {{x:number, y:number}} 返回转换后的屏幕坐标
  */
  async ClientToScreen(hwnd, x, y){
    let strData = this.setSendData('ClientToScreen', hwnd, x, y);
    return JSON.parse(await this.clientPipeServer(strData));
  }

  async MakeVideo(cmdStr){
    let strData = this.setSendData('MakeVideo', cmdStr);
    let strRet = await this.clientPipeServer(strData);
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**视频流资源下载
   * @param {string} url 视频资源链接           https://www.youtube.com/watch?v=11111111
   * @param {string} filePath  保存的mp4文件    d:\\1.mp4
   * @param {number} maxSize  最大分辨率（高度） 1920
   * @param {JSON} options 其他参数{"subLang":'zh-Hans', "thumbnail":true, "proxy": 'https://127.0.0.1:19180/', "embed": false}
   * "subLang"    视频字幕 zh-Hans中文
   * "thumbnail"  是否下载视频封面
   * "proxy"      代理服务器
   * "embed"      是否嵌入字幕
   * @return {boolean}
  */
  async YoutubeDownload(url, filePath, maxSize, options){
    let subLang = "", thumbnail = "", proxy = "", embed = "";

    if(options['subLang'] != undefined && options['subLang'] != null) 
        subLang = '--write-auto-sub --sub-lang ' + options['subLang'] + ' --convert-subtitles srt';
    if(options['thumbnail'] == true)
            thumbnail = '--write-thumbnail';
    if(options['proxy'] != undefined && options['proxy'] != null)
        proxy = '--proxy ' + options['proxy'];

    let ytdlCMD = maxSize + ']+bestaudio[ext=m4a]/best[ext=m4a]/best" -o "'+ 
                    filePath +'" ' + thumbnail + ' ' + proxy + ' '+ subLang + ' ' + url;

    console.log("正在下载视频资源...");
    let strData = this.setSendData('YoutubeDownload', ytdlCMD);
    let strRet = await this.clientPipeServer(strData);

    if(options['embed'] == true){
            let srtPath = filePath.substr(0,filePath.length-3) + options['subLang'] + '.srt';
            let tempFile = filePath.replace('.mp4', 'temp.mp4');
            
            console.log("正在嵌入字幕到视频...");
            await this.embedSubtitle(filePath, srtPath, tempFile);

            embed = 'cmd /c move /y "'+ tempFile + '" "' + filePath + '"';
            await this.StartProcess(embed, false, true);
    }
    console.log("视频处理完成！");
    if(strRet == "false")
      return false;
    else
      return true;
  }

  /**合并视频
   * @param {Array} srcVideos  字符串数组，要合并的视频文件集合
   * @param {string} destVideo 合并完成，要保存的文件名
   * @return {boolean}
  */
  async MergeVideo(srcVideos, destVideo){
    let mergeFile = "./videoTempFile.txt";
    let text = "file '"+srcVideos.join("'\nfile '") + "'";
    let cmdStr = '-f concat -safe 0 -i '+ mergeFile + ' -c copy "' + destVideo + '"';

    await fs.writeFileSync(mergeFile, text);
    let retStr = await this.MakeVideo(cmdStr);
    await fs.unlinkSync(mergeFile);
    return retStr;
  }

  /**分割视频
   * @param {string} srcVideo 视频源文件
   * @param {string} destVideo 分割完成，要保存的文件名。格式必须和 srcVideo 一致
   * @param {string} startTime 分割起始时间
   * @param {string} endTime   分割持续时间 参数格式为"23.189"(23.189秒)或者 0:0:50
   * @return {boolean}
  */
  async SplitVideo(srcVideo, destVideo, startTime, endTime){
    if(endTime.indexOf(":") == -1)
      endTime = "-t " + endTime + " ";
    else
      endTime = "-to " + endTime + " ";
    //-ss 要在 -i前面
    let cmdStr = ' -ss ' + startTime + ' -i "' + srcVideo +  '" -c copy ' + endTime + ' "' + destVideo + '"';

    return await this.MakeVideo(cmdStr);
  }

  /**导出音频
   * @param {string} videoFile 视频文件
   * @param {string} audioFile 导出的音频文件
   * @return {boolean}
  */
  async ExportAudio(videoFile, audioFile){
    let cmdStr = '-i "' + videoFile +'" -vn -codec copy "' + audioFile + '"';
    let retStr = await this.MakeVideo(cmdStr);

    if(await fs.statSync(audioFile).size == 0){
      cmdStr = '-i "' + videoFile + '" -vn "' + audioFile + '"';
      retStr = await this.MakeVideo(cmdStr);
    }
    return retStr;
  }

  /**导出视频(无声音)
   * @param {string} videoFile 视频文件
   * @param {string} naVideoFile 导出的视频文件(无声音)，导出格式必须和 videoFile 一致
   * @return {boolean}
  */
  async ExportVideo(videoFile, naVideoFile){
    let cmdStr = '-i "' + videoFile + '" -an -codec copy "' + naVideoFile + '"';
    return await this.MakeVideo(cmdStr);
  }

  /**转换视频格式
   * @param {string} srcVideo   源视频
   * @param {string} destVideo  转换后的视频
   * @return {boolean}
  */
  async ConvertVideo(srcVideo, destVideo){
    let cmdStr = '-i "' + srcVideo + '" -c:v copy -c:a copy "' + destVideo + '"';
    return await this.MakeVideo(cmdStr);
  }

  /**转换音频格式
   * @param {string} srcAudio   源音频
   * @param {string} destAudio  转换后的音频
   * @return {boolean}
  */
  async ConvertAudio(srcAudio, destAudio){
    let cmdStr = '-i "' + srcAudio + '" "' + destAudio + '"';
    return await this.MakeVideo(cmdStr);
  }

  /**转换字幕格式
   * @param {string} srcSubtitle   源字幕
   * @param {string} destSubtitle  转换后的字幕
   * @return {boolean}
  */
  async ConvertSubtitle(srcSubtitle, destSubtitle){
    let cmdStr = '-i "' + srcSubtitle + '" "' + destSubtitle + '"';
    return await this.MakeVideo(cmdStr);
  }

  /**视频嵌入字幕
   * @param {string} srcVideo     要嵌入字幕的视频文件
   * @param {string} subtitleFile 字幕文件
   * @param {string} destVideo    嵌入字幕完成的文件
   * @return {boolean}
  */
  async EmbedSubtitle(srcVideo, subtitleFile, destVideo){
    subtitleFile = subtitleFile.replace(/\\/g, '\\\\').replace(':', '\\:');
    let cmdStr = '-i "'+ srcVideo + '" -vf "subtitles=\''+ subtitleFile +'\':force_style=\'Fontsize=12\'" "' + destVideo + '"'
    return await this.MakeVideo(cmdStr);
  }

    /**视频嵌入软字幕
   * @param {string} srcVideo     要嵌入字幕的视频文件
   * @param {string} subtitleFile 字幕文件
   * @return {boolean}            成功，自动保存同名.mkv格式
  */
     async EmbedSoftSubtitle(srcVideo, subtitleFile){
      let index = srcVideo.lastIndexOf(".");
      let destVideo = srcVideo.substring(0, index) + ".mkv";
      let cmdStr = '-i "'+ srcVideo + '" -i "'+ subtitleFile + '" -vcodec copy "' + destVideo + '"';
      return await this.MakeVideo(cmdStr);
    }

  /**视频提取图片
   * @param {string} srcVideo     视频文件
   * @param {string} destImage    要提取的图片
   * @param {string} time         截图时间点 00:01:20或者80.09
   * @return {boolean}
  */
   async VideoToImage(srcVideo, destImage, time){
    let cmdStr = '-i "'+ srcVideo + '" -f image2 -ss ' + time + ' -t 0.001 "' + destImage + '"';
    return await this.MakeVideo(cmdStr);
  }

  /**视频去水印
   * @param {string} srcVideo     源视频文件
   * @param {string} destVideo    去水印后的视频文件
   * @param {JSON} rect         去水印的矩形位置 {x:10, y:20, width:100, height:200}
   * @param {number} startTime  可选参数，删除水印起始时间
   * @param {number} endTime    可选参数，删除水印结束时间
   * @return {boolean}
  */
   async DelogoVideo(srcVideo, destVideo, rect, startTime = 0, endTime = 0){
    let cmdStr = '-i "'+ srcVideo + '" -filter_complex delogo=x=' + rect.x + ':y=' + rect.y + ':w=' + rect.width + ':h=' + rect.height;
    if(endTime != 0)
      cmdStr +=':enable=\'between(t,' + startTime + ','+ endTime + ')\'';
    cmdStr += ' "' + destVideo + '"';

    return await this.MakeVideo(cmdStr);
  }

  /**视频添加水印
   * @param {string} srcVideo     源视频文件
   * @param {string} destVideo    添加印后的视频文件
   * @param {string} logoImage    水印图片
   * @param {JSON} point          水印摆放的位置{x:10, y:20}
   * @return {boolean}
  */
   async AdlogoVideo(srcVideo, destVideo, logoImage, point){
    logoImage = logoImage.replace(/\\/g, '\\\\\\\\').replace(':', '\\\\:');
    let cmdStr = '-i "'+ srcVideo + '" -vf "movie=' + logoImage + '[watermark];[in][watermark]overlay=' + point.x + ':'+ point.y+ ':[out]" "' + destVideo + '"';
    return await this.MakeVideo(cmdStr);
  }
}