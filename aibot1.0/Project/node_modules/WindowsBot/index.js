const net = require('net');
const child_process = require('child_process');
const restler = require('restler');//验证码依赖
const fs = require('fs');
const path = require("path");
const os = require('os');

class WindowsBot{
    static server;
    /**
    * @param {function(WindowsBot)} windowsMain 要注册的函数，必须含一个参数，用作接收WindowsBot对象
    * @param {string} ip 脚本所在的地址，传递给WindowsDriver.exe。如果值为 "127.0.0.1"脚本会将参数 ip和port作为启动参数并启动WindowsDriver.exe，否则用户需要手动启动WindowsDriver.exe 并且提供启动参数。
    * @param {number} port 监听端口, 传递给WindowsDriver.exe
    */
    static registerMain(windowsMain, ip, port){
        let driverName = 'WindowsDriver.exe';
        //win 7
        if(parseFloat(os.release()) < 10)
            driverName = "WindowsDriver_win7.exe";

        //本地ip由脚本服务端启动驱动程序
        if(ip == "127.0.0.1"){
            //获取驱动程序路径
            let driverPath = path.resolve(__dirname, "../../../" + driverName);
            let isExist = fs.existsSync(driverPath);
            if(!isExist)
                driverPath = driverName;

            child_process.execFile(driverPath, [ip, port]);
            console.log("正在启动WindowsDriver...");
        }

        WindowsBot.server = new net.createServer();
        WindowsBot.server.listen(port);
        WindowsBot.server.on('connection', (clientSocket) => {
            windowsMain(new WindowsBot(clientSocket));
        });
    }

    socket;
    resolveHand;
    recvData;
    recvDataLen;
    isFirstData;
    waitTimeout;
    intervalTimeout;
    mutex;
    constructor(clientSocket) {
        this.socket = clientSocket;
        this.resolveHand = null;
        this.recvData = "";
        this.isFirstData = true;//标记write首次触发data事件
        this.waitTimeout = 0;//隐式等待超时
        this.intervalTimeout = 1;//每次等待的时间
        this.mutex = new Mutex();

        this.socket.on('connect', ()=>{
            this.resolveHand(this);//返回WindowsBot
        });
        
        this.socket.on('error', error=>{
            console.log(error);
        });
        
        this.socket.on('close', ()=>{
            console.log('WindowsBot已关闭');
        });

        this.socket.on('data', data => {
            if(this.isFirstData){
                this.isFirstData = false;
                let strData = data.toString();
                let index = strData.indexOf("/");
                this.recvDataLen = parseInt(strData.substring(0, index), 10);
                //重新赋值
                this.recvData = data.slice(index + 1);
            }else{
                this.recvData = Buffer.concat([this.recvData, data]);
            }

            if (this.resolveHand && this.recvDataLen == this.recvData.length) {
                //清理现场
                this.isFirstData = true;
                this.resolveHand(this.recvData);
                this.resolveHand = null;
                this.mutex.release();//释放锁
            }
        });
    }

    static sleep(millisecond){
        return new Promise(resolve => {setTimeout(() => {resolve()}, millisecond)});
    }

    /**构建windowsBot
     * @param {string} ip windowsBot服务端地址，假如值为 "127.0.0.1"脚本会自动启动WindowsDriver.exe，如果是远程服务地址，用户需要手动启动WindowsDriver.exe 并且提供启动参数。
     * 命令行启动示例：WindowsDriver.exe 19999
     * @param {number} port windowsBot服务端端口, 默认 19999
     * @return {Promise.<WindowsBot>}
    */
    static async build(ip, port = 19999){
        if(ip == "127.0.0.1"){
            //获取驱动程序路径
            let driverPath = path.resolve(__dirname, "../../../WindowsDriver.exe");
            let isExist = await fs.existsSync(driverPath);
            if(!isExist)
                driverPath = 'WindowsDriver.exe';

            child_process.execFile(driverPath, [port]);
            console.log("正在启动WindowsDriver...");
            await this.sleep(3000);
        }
        return new Promise((resolve) => {
            new WindowsBot(ip, port, resolve);
        });
    }

    setSendData = (...arrArgs) =>{
        // len/len/len\ndata
        let strData = "";
        let tempStr = "";
        arrArgs.forEach((args) =>{
          if(args == null)
            args = "";
          tempStr += args;
          strData += Buffer.byteLength(args.toString(), "utf8");//获取包含中文实际长度
          strData += '/';
        });
        strData += '\n';
        strData += tempStr;
        return strData;
    }

    /**发送数据
    * @param {string} strData
    * @return {string}
    */
    sendData = (strData)=>{
        return new Promise(async (resolve) => {
            await this.mutex.lock();//加队列锁，防止数据并发
            this.resolveHand = resolve;
            this.socket.write(strData);
        })
    }

    /**睡眠等待
     * @param {number} millisecond  等待时间,单位毫秒
     * @return {Promise.<void>}
    */
    async sleep(millisecond){
        return new Promise(resolve => {setTimeout(() => {resolve()}, millisecond)});
    }

    /**设置隐式等待
     * @param {number} waitMs  等待时间,单位毫秒
     * @param {number} intervalMs 心跳间隔，单位毫秒。可选参数，默认10毫秒
     * @return {Promise.<void>}
    */
    async setImplicitTimeout(waitMs, intervalMs = 10){
        this.waitTimeout = waitMs;
        this.intervalTimeout = intervalMs;
    }

    /**查找窗口句柄
     * @param {string} className  窗口类名
     * @param {string} windowNmae 窗口名
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findWindow(className, windowNmae){
        let strData = this.setSendData("findWindow", className, windowNmae);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**查找窗口句柄数组
     * @param {string} className  窗口类名
     * @param {string} windowNmae 窗口名
     * @return {Promise.<[]>} 成功返回窗口句柄数组，失败返回null
    */
    async findWindows(className, windowNmae){
        let strData = this.setSendData("findWindows", className, windowNmae);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet.split("|");
    }

    /**查找子窗口句柄
     * @param {string|number} curHwnd  当前窗口句柄
     * @param {string} className  窗口类名
     * @param {string} windowNmae 窗口名
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findSubWindow(curHwnd, className, windowNmae){
        let strData = this.setSendData("findSubWindow", curHwnd, className, windowNmae);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**查找父窗口句柄
     * @param {string|number} curHwnd  当前窗口句柄
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findParentWindow(curHwnd){
        let strData = this.setSendData("findParentWindow", curHwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**查找桌面窗口句柄
     * @return {Promise.<string>} 成功返回窗口句柄，失败返回null
    */
    async findDesktopWindow(){
        let strData = this.setSendData("findDesktopWindow");
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**获取窗口名称
     * @param {string|number} hwnd 窗口句柄
     * @return {Promise.<string>} 成功返回窗口名称，失败返回null
    */
    async getWindowName(hwnd){
        let strData = this.setSendData("getWindowName", hwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**显示/隐藏窗口
     * @param {string|number} hwnd 窗口句柄
     * @param {boolean} isShow 显示窗口 true， 隐藏窗口 false
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
     async showWindow(hwnd, isShow){
        let strData = this.setSendData("showWindow", hwnd, isShow);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置窗口到最顶层
     * @param {string|number} hwnd 窗口句柄
     * @param {boolean} isTop 是否置顶，true置顶， false取消置顶
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async setWindowTop(hwnd, isTop){
        let strData = this.setSendData("setWindowTop", hwnd, isTop);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**获取窗口位置
     * @param {string|number} hwnd  窗口句柄
     * @return {Promise.<{left:number, top:number, width:number, height:number}>} 成功返回窗口位置，失败返回null
    */
    async getWindowPos(hwnd){
        let strData = this.setSendData('getWindowPos', hwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "-1|-1|-1|-1")
            return null;
        let arrRet = strRet.split("|");
        return {left: parseInt(arrRet[0]), top: parseInt(arrRet[1]), width: parseInt(arrRet[2]), height: parseInt(arrRet[3])};
    }

    /**设置窗口位置
     * @param {string|number} hwnd  窗口句柄
     * @param {number} left 左上角横坐标
     * @param {number} top 左上角纵坐标
     * @param {number} width 窗口宽度
     * @param {number} height 窗口高度
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setWindowPos(hwnd, left, top, width, height){
        let strData = this.setSendData('setWindowPos', hwnd, left, top, width, height);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**移动鼠标
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  横坐标
     * @param {number} y  纵坐标
     * @param {{mode:boolean, elementHwnd:string|number}} options 操作模式，后台 true，前台 false。默认前台操作。
     * 如果mode值为true且目标控件有单独的句柄，则需要通过getElementWindow获得元素句柄，指定elementHwnd的值(极少应用窗口由父窗口响应消息，则无需指定)
     * @return {Promise.<boolean>} 总是返回true
    */
    async moveMouse(hwnd, x, y, options = {}){
        let mode = false;
        let elementHwnd = 0;
        if(options["mode"] != undefined)
            mode = options["mode"];
        if(options["elementHwnd"] != undefined)
            elementHwnd = options["elementHwnd"];

        let strData = this.setSendData("moveMouse", hwnd, x, y, mode, elementHwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**移动鼠标(相对坐标)
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  相对横坐标
     * @param {number} y  相对纵坐标
     * @param {boolean} mode  操作模式，后台 true，前台 false。默认前台操作
     * @return {Promise.<boolean>} 总是返回true
    */
    async moveMouseRelative(hwnd, x, y, mode = false){
        let strData = this.setSendData("moveMouseRelative", hwnd, x, y, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**滚动鼠标
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  横坐标
     * @param {number} y  纵坐标
     * @param {number} dwData 鼠标滚动次数,负数下滚鼠标,正数上滚鼠标
     * @param {boolean} mode  操作模式，后台 true，前台 false。默认前台操作
     * @return {Promise.<boolean>} 总是返回true
    */
    async rollMouse(hwnd, x, y, dwData, mode = false){
        let strData = this.setSendData("rollMouse", hwnd, x, y, dwData, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**鼠标点击
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x  横坐标
     * @param {number} y  纵坐标
     * @param {number} msg 单击左键:1 单击右键:2 按下左键:3 弹起左键:4 按下右键:5 弹起右键:6 双击左键:7 双击右键:8
     * @param {{mode:boolean, elementHwnd:string|number}} options 操作模式，后台 true，前台 false。默认前台操作。
     * 如果mode值为true且目标控件有单独的句柄，则需要通过getElementWindow获得元素句柄，指定elementHwnd的值(极少应用窗口由父窗口响应消息，则无需指定)
     * @return {Promise.<boolean>} 总是返回true。
    */
    async clickMouse(hwnd, x, y, msg, options = {}){
        let mode = false;
        let elementHwnd = 0;
        if(options["mode"] != undefined)
            mode = options["mode"];
        if(options["elementHwnd"] != undefined)
            elementHwnd = options["elementHwnd"];

        let strData = this.setSendData("clickMouse", hwnd, x, y, msg, mode, elementHwnd);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**输入文本
     * @param {string} text  输入的文本
     * @return {Promise.<boolean>} 总是返回true
    */
    async sendKeys(text){
        let strData = this.setSendData("sendKeys", text);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**后台输入文本
     * @param {string|number} hwnd 窗口句柄，如果目标控件有单独的句柄，需要通过getElementWindow获得句柄
     * @param {string} text  输入的文本
     * @return {Promise.<boolean>} 总是返回true
    */
     async sendKeysByHwnd(hwnd, text){
        let strData = this.setSendData("sendKeysByHwnd", hwnd, text);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**输入虚拟键值(VK)
     * @param {number} bVk VK键值，例如：回车对应 VK键值 13
     * @param {number} msg 按下弹起:1 按下:2 弹起:3
     * @return {Promise.<boolean>} 总是返回true
    */
    async sendVk(bVk, msg){
        let strData = this.setSendData("sendVk", bVk, msg);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**后台输入虚拟键值(VK)
     * @param {string|number} hwnd  窗口句柄，如果目标控件有单独的句柄，需要通过getElementWindow获得句柄
     * @param {number} bVk VK键值，例如：回车对应 VK键值 13
     * @param {number} msg 按下弹起:1 按下:2 弹起:3
     * @return {Promise.<boolean>} 总是返回true。若是后台组合键，可使用sendVk 按下控制键(AltShiftCtrl...)，再组合其他按键
    */
    async sendVkByHwnd(hwnd, bVk, msg){
        let strData = this.setSendData("sendVkByHwnd", hwnd, bVk, msg);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**截图保存
     * @param {string|number} hwnd  窗口句柄
     * @param {string} savePath 保存的位置
     * @param {{region:[left:number, top:number, right:number, bottom:number], threshold:[thresholdType:number, thresh:number, maxval:number], mode:boolean}} options 可选参数
     * region截图区域 [10, 20, 100, 200]，region默认  hwnd对应的窗口
     * threshold二值化图片, thresholdType算法类型：
                                                0   THRESH_BINARY算法，当前点值大于阈值thresh时，取最大值maxva，否则设置为0
                                                1   THRESH_BINARY_INV算法，当前点值大于阈值thresh时，设置为0，否则设置为最大值maxva
                                                2   THRESH_TOZERO算法，当前点值大于阈值thresh时，不改变，否则设置为0
                                                3   THRESH_TOZERO_INV算法，当前点值大于阈值thresh时，设置为0，否则不改变
                                                4   THRESH_TRUNC算法，当前点值大于阈值thresh时，设置为阈值thresh，否则不改变
                                                5   ADAPTIVE_THRESH_MEAN_C算法，自适应阈值
                                                6   ADAPTIVE_THRESH_GAUSSIAN_C算法，自适应阈值
                            thresh阈值，maxval最大值，threshold默认保存原图。thresh和maxval同为255时灰度处理
    * mode操作模式，后台 true，前台 false。默认前台操作       
     * @return {Promise.<boolean>}
    */
    async saveScreenshot(hwnd, savePath, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        let thresholdType = 0, thresh = 0, maxval = 0;
        let mode = false;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["threshold"] != undefined){
            thresholdType = options["threshold"][0];
            if(thresholdType == 5 || thresholdType == 6){
                thresh = 127;
                maxval = 255;
            }else{
                thresh = options["threshold"][1];
                maxval = options["threshold"][2];
            }
        }
        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("saveScreenshot", hwnd, savePath, left, top, right, bottom, thresholdType, thresh, maxval, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**获取指定坐标点的色值
     * @param {string|number} hwnd  窗口句柄
     * @param {number} x 横坐标
     * @param {number} y 纵坐标 
     * @param {boolean} mode 操作模式，后台 true，前台 false。默认前台操作
     * @return {Promise.<string>} 成功返回#开头的颜色值，失败返回null
    */
    async getColor(hwnd, x, y, mode = false){
        let strData = this.setSendData("getColor", hwnd, x, y, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**找图
     * @param {string|number} hwndOrBigImagePath  窗口句柄或者图片路径
     * @param {string} smallImagePath 小图片路径，多张小图查找应当用"|"分开小图路径
     * @param {{region:[left:number, top:number, right:number, bottom:number], sim:number, threshold:[thresholdType:number, thresh:number, maxval:number], multi:number, mode:boolean}} options 可选参数
     * region 指定区域找图 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * sim浮点型 图片相似度 0.0-1.0，sim默认0.95 
     * threshold二值化图片, thresholdType算法类型：
                                                0   THRESH_BINARY算法，当前点值大于阈值thresh时，取最大值maxva，否则设置为0
                                                1   THRESH_BINARY_INV算法，当前点值大于阈值thresh时，设置为0，否则设置为最大值maxva
                                                2   THRESH_TOZERO算法，当前点值大于阈值thresh时，不改变，否则设置为0
                                                3   THRESH_TOZERO_INV算法，当前点值大于阈值thresh时，设置为0，否则不改变
                                                4   THRESH_TRUNC算法，当前点值大于阈值thresh时，设置为阈值thresh，否则不改变
                                                5   ADAPTIVE_THRESH_MEAN_C算法，自适应阈值
                                                6   ADAPTIVE_THRESH_GAUSSIAN_C算法，自适应阈值
                            thresh阈值，maxval最大值，threshold默认保存原图。thresh和maxval同为255时灰度处理
     * multi 找图数量，默认为1 找单个图片坐标
     * mode 操作模式，后台 true，前台 false。默认前台操作。hwndOrBigImagePath为图片文件，此参数无效
     * @return {Promise.<[{x:number, y:number}]>} 成功返回 单坐标点[{x:number, y:number}]，多坐标点[{x1:number, y1:number}, {x2:number, y2:number}...] 失败返回null
    */
    async findImage(hwndOrBigImagePath, smallImagePath, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        let sim = 0.95;
        let thresholdType = 0, thresh = 0, maxval = 0;
        let multi = 1;
        let mode = false;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["sim"] != undefined)
            sim = options["sim"];
        if(options["threshold"] != undefined){
            thresholdType = options["threshold"][0];
            if(thresholdType == 5 || thresholdType == 6){
                thresh = 127;
                maxval = 255;
            }else{
                thresh = options["threshold"][1];
                maxval = options["threshold"][2];
            }
        }
        if(options["multi"] != undefined)
            multi = options["multi"];

        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData;
        if(hwndOrBigImagePath.toString().indexOf(".") == -1)//在窗口上找图
            strData = this.setSendData("findImage", hwndOrBigImagePath, smallImagePath, left, top, right, bottom, sim, thresholdType, thresh, maxval, multi, mode);
        else//在文件上找图
            strData = this.setSendData("findImageByFile", hwndOrBigImagePath, smallImagePath, left, top, right, bottom, sim, thresholdType, thresh, maxval, multi, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1")
            return null;

        let arrPoints = strRet.split("/");
        let pointCount = arrPoints.length;
        let arrRet = [];
        let arrPoint;
        for(let i = 0; i < pointCount; i++){
            arrPoint = arrPoints[i].split("|");
            arrRet[i] = {x: parseInt(arrPoint[0]), y: parseInt(arrPoint[1])};
        }
        return arrRet;
    }

    /**找动态图
     * @param {string|number} hwnd  窗口句柄
     * @param {number} frameRate 前后两张图相隔的时间，单位毫秒
     * @param {{region:[left:number, top:number, right:number, bottom:number], mode:boolean}} options 可选参数
     * region 指定区域找图 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<[{x:number, y:number}]>} 成功返回 单坐标点[{x:number, y:number}]，多坐标点[{x1:number, y1:number}, {x2:number, y2:number}...] 失败返回null
    */
    async findAnimation(hwnd, frameRate, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        let mode = false;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }

        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("findAnimation", hwnd, frameRate, left, top, right, bottom, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1")
            return null;

        let arrPoints = strRet.split("/");
        let pointCount = arrPoints.length;
        let arrRet = [];
        let arrPoint;
        for(let i = 0; i < pointCount; i++){
            arrPoint = arrPoints[i].split("|");
            arrRet[i] = {x: parseInt(arrPoint[0]), y: parseInt(arrPoint[1])};
        }
        return arrRet;
    }

    /**查找指定色值的坐标点
     * @param {string|number} hwnd  窗口句柄
     * @param {string} strMainColor #开头的色值
     * @param {{subColors:[[offsetX:number, offsetY:number, strSubColor:string], ...], region:[left:number, top:number, right:number, bottom:number], sim:number, mode:boolean}} options 可选参数
     * subColors 相对于strMainColor 的子色值，[[offsetX, offsetY, "#FFFFFF"], ...]，subColors默认为null
     * region 指定区域找色 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * sim相似度0.0-1.0，sim默认为1
     * mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<{x:number, y:number}>} 成功返回{x:number, y:number} 失败返回null
    */
    async findColor(hwnd, strMainColor, options = {}){
        let strSubColors = "null";
        let left = 0, top = 0, right = 0, bottom = 0;
        let sim = 1;
        let mode = false;
        if(options["subColors"] != undefined){
            strSubColors = "";
            let arrLen = options["subColors"].length;
            for(let i = 0; i < arrLen; i++){
                strSubColors += options["subColors"][i][0] + "/";
                strSubColors += options["subColors"][i][1] + "/";
                strSubColors += options["subColors"][i][2];
                if(i < arrLen - 1)
                    strSubColors += "\n";
            }
        }
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["sim"] != undefined)
            sim = options["sim"];
        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("findColor", hwnd, strMainColor, strSubColors, left, top, right, bottom, sim, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1")
            return null;
        let arrRet = strRet.split("|");
        return {x: parseInt(arrRet[0]), y: parseInt(arrRet[1])};
    }

    /**比较指定坐标点的颜色值
     * @param {string|number} hwnd  窗口句柄
     * @param {number} mainX 主颜色所在的X坐标
     * @param {number} mainY 主颜色所在的Y坐标
     * @param {string} strMainColor #开头的色值
     * @param {{subColors:[[offsetX:number, offsetY:number, strSubColor:string], ...], region:[left:number, top:number, right:number, bottom:number], sim:number, mode:boolean}} options 可选参数
     * subColors 相对于strMainColor 的子色值，[[offsetX, offsetY, "#FFFFFF"], ...]，subColors默认为null
     * region 指定区域找色 [10, 20, 100, 200]，region默认 hwnd对应的窗口
     * sim相似度0.0-1.0，sim默认为1
     * mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async compareColor(hwnd, mainX, mainY, strMainColor, options = {}){
        let strSubColors = "null";
        let left = 0, top = 0, right = 0, bottom = 0;
        let sim = 1;
        let mode = false;
        if(options["subColors"] != undefined){
            strSubColors = "";
            let arrLen = options["subColors"].length;
            for(let i = 0; i < arrLen; i++){
                strSubColors += options["subColors"][i][0] + "/";
                strSubColors += options["subColors"][i][1] + "/";
                strSubColors += options["subColors"][i][2];
                if(i < arrLen - 1)
                    strSubColors += "\n";
            }
        }
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }
        if(options["sim"] != undefined)
            sim = options["sim"];
        if(options["mode"] != undefined)
            mode = options["mode"];

        let strData = this.setSendData("compareColor", hwnd, mainX, mainY, strMainColor, strSubColors, left, top, right, bottom, sim, mode);
        let strRet, byteRet;
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**提取视频帧
     * @param {string} videoPath 视频路径
     * @param {string} saveFolder 提取的图片保存的文件夹目录
     * @param {number} jumpFrame 跳帧，默认为1 不跳帧
     * @return {Promise.<boolean>}成功返回true，失败返回false
    */
    async extractImageByVideo(videoPath, saveFolder, jumpFrame = 1){
        let strData = this.setSendData("extractImageByVideo", videoPath, saveFolder, jumpFrame);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true; 
    }

    /**裁剪图片
     * @param {string} imagePath 图片路径
     * @param {string} savePath 裁剪后保存的图片路径
     * @param {number} left 裁剪的左上角横坐标
     * @param {number} top 裁剪的左上角纵坐标
     * @param {number} rigth 裁剪的右下角横坐标
     * @param {number} bottom 裁剪的右下角纵坐标
     * @return {Promise.<boolean>}成功返回true，失败返回false
    */
    async cropImage(imagePath, savePath, left, top, rigth, bottom){
        let strData = this.setSendData("cropImage", imagePath, savePath, left, top, rigth, bottom);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true; 
    }

    /**初始化ocr服务
     * @param {string} ocrServerIp  ocr服务器IP
     * @param {number} ocrServerPort ocr服务器端口，默认9528
     * @return {Promise.<boolean>} 总是返回true
    */
    async initOcr(ocrServerIp, ocrServerPort = 9528){
        let strData = this.setSendData("initOcr", ocrServerIp, ocrServerPort);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true; 
    }

    //解析ocr
    splitOcr = async(strOcr) => {
        let wordsResult = [];
        
        //删除第一个"[" 和最后一个"]"
        strOcr = strOcr.slice(1);
        strOcr = strOcr.slice(0, strOcr.length - 1);

        //特殊处理 字符串包含 双引号"
        if(strOcr.indexOf(", ('") != -1)
            strOcr = strOcr.replace(/"/g, '\\\"');

        let arrOcr = strOcr.split(")]");
        let strTemp, index;

        for(let i = 0; i < arrOcr.length - 1; i++){
            if(i == 0)
                strTemp = arrOcr[i].replace(/\[/, '{"location":');
            else
                strTemp = arrOcr[i].replace(/, \[/, '{"location":');
            strTemp = strTemp.replace(/\, \('/, ',"words":"');
            strTemp = strTemp.replace(/\, \("/, ',"words":"');//特殊处理 字符串包含 单引号'
            index = strTemp.lastIndexOf("', ");
            //特殊处理 字符串包含 单引号'
            if(index == -1)
                index = strTemp.lastIndexOf("\", ");

            strTemp = strTemp.substring(0, index) + "\"}";
            wordsResult[i] = JSON.parse(strTemp);
        }
        
        return wordsResult;
    }

    /**ocr
     * @param {string|number} hwnd  窗口句柄
     * @param {left:number} left 左上角x点
     * @param {top:number} top 左上角y点
     * @param {right:number} right 右下角 x点
     * @param {bottom:number} bottom 右下角 y点
     * @param {thresholdType:number} thresholdType 二值化算法类型
     * @param {thresh:number} thresh 阈值
     * @param {maxval:number} maxval 最大值
     * @param {mode:boolean} mode 操作模式，后台 true，前台 false。默认前台操作   
     * @return {Promise.<[]>} 失败返回null，成功返回数组形式的识别结果
    */
    ocr = async (hwnd, left, top, right, bottom, thresholdType, thresh, maxval, mode = false) =>{
        let strData = this.setSendData("ocr", hwnd, left, top, right, bottom, thresholdType, thresh, maxval, mode);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null" || strRet == "")
            return null;
        else
            return this.splitOcr(strRet);
    }

    /**ocrByFile
     * @param {string} imagePath 图片路径
     * @param {left:number} left 左上角x点
     * @param {top:number} top 左上角y点
     * @param {right:number} right 右下角 x点
     * @param {bottom:number} bottom 右下角 y点
     * @param {thresholdType:number} thresholdType 二值化算法类型
     * @param {thresh:number} thresh 阈值
     * @param {maxval:number} maxval 最大值
     * @return {Promise.<[]>} 失败返回null，成功返回数组形式的识别结果
    */
     ocrByFile = async (imagePath, left, top, right, bottom, thresholdType, thresh, maxval) =>{
        let strData = this.setSendData("ocrByFile", imagePath, left, top, right, bottom, thresholdType, thresh, maxval);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null" || strRet == "")
            return null;
        else
            return this.splitOcr(strRet);
    }

    /**获取屏幕文字
     * @param {string|number} hwndOrImagePath  窗口句柄或者图片路径
     * @param {{region:[left:number, top:number, right:number, bottom:number], threshold:[thresholdType:number, thresh:number, maxval:number], mode:boolean}} options 可选参数
     * region 指定区域 [10, 20, 100, 200]，region默认全图
     * threshold二值化图片, thresholdType算法类型：
                                                0   THRESH_BINARY算法，当前点值大于阈值thresh时，取最大值maxva，否则设置为0
                                                1   THRESH_BINARY_INV算法，当前点值大于阈值thresh时，设置为0，否则设置为最大值maxva
                                                2   THRESH_TOZERO算法，当前点值大于阈值thresh时，不改变，否则设置为0
                                                3   THRESH_TOZERO_INV算法，当前点值大于阈值thresh时，设置为0，否则不改变
                                                4   THRESH_TRUNC算法，当前点值大于阈值thresh时，设置为阈值thresh，否则不改变
                                                5   ADAPTIVE_THRESH_MEAN_C算法，自适应阈值
                                                6   ADAPTIVE_THRESH_GAUSSIAN_C算法，自适应阈值
                            thresh阈值，maxval最大值，threshold默认保存原图。thresh和maxval同为255时灰度处理
     * mode 操作模式，后台 true，前台 false。默认前台操作, 仅适用于hwnd
     * @return {Promise.<string>} 失败返回null，成功返窗口上的文字
    */
    async getWords(hwndOrImagePath, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }

        let thresholdType = 0, thresh = 0, maxval = 0;
        if(options["threshold"] != undefined){
            thresholdType = options["threshold"][0];
            if(thresholdType == 5 || thresholdType == 6){
                thresh = 127;
                maxval = 255;
            }else{
                thresh = options["threshold"][1];
                maxval = options["threshold"][2];
            }
        }

        let wordsResult;
        if(hwndOrImagePath.indexOf(".") == -1){
            let mode = false;
            if(options["mode"] != undefined)
                mode = options["mode"];
            wordsResult = await this.ocr(hwndOrImagePath, left, top, right, bottom, thresholdType, thresh, maxval, mode);
        }
        else
            wordsResult = await this.ocrByFile(hwndOrImagePath, left, top, right, bottom, thresholdType, thresh, maxval);
        
        if(wordsResult == null)
            return null;
        
        let words = "";
        let i;
        for(i = 0; i < wordsResult.length - 1; i++)
            words += wordsResult[i].words + "\n";
        words += wordsResult[i].words

        return words;
    }

    /**查找文字
     * @param {string|number} hwndOrImagePath  窗口句柄或者图片路径
     * @param {string} words 要查找的文字
     * @param {{region:[left:number, top:number, right:number, bottom:number], threshold:[thresholdType:number, thresh:number, maxval:number], mode:boolean}} options 可选参数
     * region 指定区域 [10, 20, 100, 200]，region默认全图
     * threshold二值化图片, thresholdType算法类型：
                                                0   THRESH_BINARY算法，当前点值大于阈值thresh时，取最大值maxva，否则设置为0
                                                1   THRESH_BINARY_INV算法，当前点值大于阈值thresh时，设置为0，否则设置为最大值maxva
                                                2   THRESH_TOZERO算法，当前点值大于阈值thresh时，不改变，否则设置为0
                                                3   THRESH_TOZERO_INV算法，当前点值大于阈值thresh时，设置为0，否则不改变
                                                4   THRESH_TRUNC算法，当前点值大于阈值thresh时，设置为阈值thresh，否则不改变
                                                5   ADAPTIVE_THRESH_MEAN_C算法，自适应阈值
                                                6   ADAPTIVE_THRESH_GAUSSIAN_C算法，自适应阈值
                            thresh阈值，maxval最大值，threshold默认保存原图。thresh和maxval同为255时灰度处理
     * mode 操作模式，后台 true，前台 false。默认前台操作, 仅适用于hwnd
     * @return {Promise.<[{x:number, y:number}]>} 失败返回null，成功返回数组[{x:number, y:number}, ...]，文字所在的坐标点
    */
    async findWords(hwndOrImagePath, words, options = {}){
        let left = 0, top = 0, right = 0, bottom = 0;
        if(options["region"] != undefined){
            left = options["region"][0];
            top = options["region"][1];
            right = options["region"][2];
            bottom = options["region"][3];
        }

        let thresholdType = 0, thresh = 0, maxval = 0;
        if(options["threshold"] != undefined){
            thresholdType = options["threshold"][0];
            if(thresholdType == 5 || thresholdType == 6){
                thresh = 127;
                maxval = 255;
            }else{
                thresh = options["threshold"][1];
                maxval = options["threshold"][2];
            }
        }

        let wordsResult;
        if(hwndOrImagePath.toString().indexOf(".") == -1){
            let mode = false;
            if(options["mode"] != undefined)
                mode = options["mode"];
            wordsResult = await this.ocr(hwndOrImagePath, left, top, right, bottom, thresholdType, thresh, maxval, mode);
        }
        else
            wordsResult = await this.ocrByFile(hwndOrImagePath, left, top, right, bottom, thresholdType, thresh, maxval);
            
        if(wordsResult == null)
            return null;

        let points = [];
        let localLeft, localTop, localRight, localBottom, width, height;
        let wordWidth, index, offsetX, offsetY, x, y;
        for(let i = 0, j = 0; i < wordsResult.length; i++){
            index = wordsResult[i].words.indexOf(words);
            if(index != -1){
                localLeft = wordsResult[i].location[0][0];
                localTop = wordsResult[i].location[0][1];
                localRight = wordsResult[i].location[2][0];
                localBottom = wordsResult[i].location[2][1];
                width = localRight - localLeft;
                height = localBottom - localTop;

                wordWidth = width / wordsResult[i].words.length;
                offsetX = wordWidth * (index + words.length / 2);
                offsetY = height / 2;
                x = parseInt(localLeft + offsetX + left);
                y = parseInt(localTop + offsetY + top);
                points[j] = {"x":x, "y":y};
                j++;
            }
        }
        
        if(points.length == 0)
            return null;
        else    
            return points;
    }
    
    /**获取指定元素名称
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @return {Promise.<string>} 成功返回元素名称
    */
    async getElementName(hwnd, xpath){
        let strData = this.setSendData('getElementName', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "null")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**获取指定元素文本
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<string>} 成功返回元素文本
    */
    async getElementValue(hwnd, xpath){
        let strData = this.setSendData('getElementValue', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "null")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**获取指定元素矩形大小
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @return {Promise.<{left:number, top:number, right:number, bottom:number}>} 成功返回元素位置，失败返回null
    */
    async getElementRect(hwnd, xpath){
        let strData = this.setSendData('getElementRect', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "-1|-1|-1|-1")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "-1|-1|-1|-1")
            return null;
        let arrRet = strRet.split("|");
        return {left: parseInt(arrRet[0]), top: parseInt(arrRet[1]), right: parseInt(arrRet[2]), bottom: parseInt(arrRet[3])};
    }

    /**获取元素窗口句柄
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<string>} 成功返回元素窗口句柄，失败返回null
    */
     async getElementWindow(hwnd, xpath){
        let strData = this.setSendData('getElementWindow', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "null")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);

        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**点击元素
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @param {number} msg 单击左键:1 单击右键:2 按下左键:3 弹起左键:4 按下右键:5 弹起右键:6 双击左键:7 双击右键:8
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async clickElement(hwnd, xpath, msg){
        let strData = this.setSendData('clickElement', hwnd, xpath, msg);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**执行元素默认操作(一般是点击操作)
     * @param {string|number} hwnd  窗口句柄。
     * @param {string} xpath 元素路径
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async invokeElement(hwnd, xpath){
        let strData = this.setSendData('invokeElement', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置指定元素作为焦点
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setElementFocus(hwnd, xpath){
        let strData = this.setSendData('setElementFocus', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置元素文本
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @param {string} value 要设置的内容
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setElementValue(hwnd, xpath, value){
        let strData = this.setSendData('setElementValue', hwnd, xpath, value);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**滚动元素
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @param {number} horizontalPercent 水平百分比 -1不滚动
     * @param {number} verticalPercent 垂直百分比 -1不滚动
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
     async setElementScroll(hwnd, xpath, horizontalPercent, verticalPercent){
        let strData = this.setSendData('setElementScroll', hwnd, xpath, horizontalPercent, verticalPercent);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**单/复选框是否选中
     * @param {string|number} hwnd  窗口句柄
     * @param {string} xpath 元素路径
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async isSelected(hwnd, xpath){
        let strData = this.setSendData('isSelected', hwnd, xpath);
        let startTime = process.uptime() * 1000;
        let endTime = process.uptime() * 1000;
        let strRet, byteRet;
        do{
            byteRet = await this.sendData(strData);
            strRet = byteRet.toString();
            if(strRet == "false")
                await this.sleep(this.intervalTimeout);
            else
                break;
            endTime = process.uptime() * 1000;
        }while(endTime - startTime <= this.waitTimeout);
        
        if(strRet == "selected")
            return true;
        else
            return false;
    }

    /**关闭窗口
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async closeWindow(hwnd, xpath){
        let strData = this.setSendData('closeWindow', hwnd, xpath);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置窗口状态
     * @param {string|number} hwnd  窗口句柄。如果是java窗口并且窗口句柄和元素句柄不一致，需要使用getElementWindow获取窗口句柄。
     * getElementWindow参数的xpath，Aibote Tool应当使用正常模式下获取的XPATH路径，不要 “勾选java窗口” 复选按钮。对话框子窗口，需要获取对应的窗口句柄操作
     * @param {string} xpath 元素路径
     * @param {number} state 0正常 1最大化 2 最小化
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setWindowState(hwnd, xpath, state){
        let strData = this.setSendData('setWindowState', hwnd, xpath, state);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**设置剪切板文本
     * @param {string} text 设置的文本
     * @return {Promise.<boolean>} 成功返回true 失败返回 false
    */
    async setClipboardText(text){
        let strData = this.setSendData('setClipboardText', text);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**获取剪切板文本
     * @return {Promise.<string>} 返回剪切板文本
    */
    async getClipboardText(){
        let strData = this.setSendData('getClipboardText');
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return strRet;
    }

    /**启动指定程序
     * @param {string} commandLine 启动命令行
     * @param {boolean} showWindow 是否显示窗口。可选参数,默认显示窗口
     * @param {boolean} isWait 是否等待程序结束。可选参数,默认不等待
     * @return {Promise.<boolean>} 成功返回true,失败返回false
    */
    async startProcess(commandLine, showWindow = true, isWait = false){
        let strData = this.setSendData('startProcess', commandLine, showWindow, isWait);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**执行cmd命令
     * @param {string} command cmd命令，不能含 "cmd"字串
     * @param {number} waitTimeout 可选参数，等待结果返回超时，单位毫秒，默认300毫秒
     * @return {Promise.<string>} 返回cmd执行结果
    */
    async executeCommand(command, waitTimeout = 300){
        let strData = this.setSendData('executeCommand', command, waitTimeout);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return strRet;
    }

    /**指定url下载文件
     * @param {string} url 文件地址
     * @param {string} filePath 文件保存的路径
     * @param {boolean} isWait 是否等待.为true时,等待下载完成
     * @return {Promise.<boolean>} 总是返回true
    */
    async downloadFile(url, filePath, isWait){
        let strData = this.setSendData('downloadFile', url, filePath, isWait);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return true;
    }

    /**打开excel文档
     * @param {string} excelPath excle路径
     * @return {Promise.<Object>} 成功返回excel对象，失败返回null
    */
    async openExcel(excelPath){
        let strData = this.setSendData('openExcel', excelPath);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);
    }

    /**打开excel表格
     * @param {Object} excelObject excel对象
     * @param {string} sheetName 表名
     * @return {Promise.<Object>} 成功返回sheet对象，失败返回null
    */
    async openExcelSheet(excelObject, sheetName){
        let strData = this.setSendData('openExcelSheet', excelObject['book'], excelObject['path'], sheetName);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**保存excel文档
     * @param {Object} excelObject excel对象
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async saveExcel(excelObject){
        let strData = this.setSendData('saveExcel', excelObject['book'], excelObject['path']);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**写入数字到excel表格
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @param {number} value 写入的值
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async writeExcelNum(sheetObject, row, col, value){
        let strData = this.setSendData('writeExcelNum', sheetObject, row, col, value);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**写入字符串到excel表格
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @param {string} strValue 写入的值
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async writeExcelStr(sheetObject, row, col, strValue){
        let strData = this.setSendData('writeExcelStr', sheetObject, row, col, strValue);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**读取excel表格数字
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @return {Promise.<number>} 返回读取到的数字
    */
    async readExcelNum(sheetObject, row, col){
        let strData = this.setSendData('readExcelNum', sheetObject, row, col);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return parseFloat(strRet);
    }

    /**读取excel表格字串
     * @param {Object} sheetObject sheet对象
     * @param {number} row 行
     * @param {number} col 列
     * @return {Promise.<string>} 返回读取到的字符
    */
    async readExcelStr(sheetObject, row, col){
        let strData = this.setSendData('readExcelStr', sheetObject, row, col);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return strRet;
    }

    /**删除excel表格行
     * @param {Object} sheetObject sheet对象
     * @param {number} rowFirst 起始行
     * @param {number} rowLast 结束行
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async removeExcelRow(sheetObject, rowFirst, rowLast){
        let strData = this.setSendData('removeExcelRow', sheetObject, rowFirst, rowLast);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**删除excel表格列
     * @param {Object} sheetObject sheet对象
     * @param {number} colFirst 起始列
     * @param {number} colLast 结束列
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async removeExcelCol(sheetObject, colFirst, colLast){
        let strData = this.setSendData('removeExcelCol', sheetObject, colFirst, colLast);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**识别验证码
    * @param {string} filePath 图片文件路径
    * @param {string} username 用户名
    * @param {string} password 密码
    * @param {string} softId 软件ID
    * @param {string} codeType 图片类型 参考https://www.chaojiying.com/price.html
    * @param {string} lenMin 最小位数 默认0为不启用,图片类型为可变位长时可启用这个参数
    * @return {Promise.<{err_no:number, err_str:string, pic_id:string, pic_str:string, md5:string}>} 返回JSON
    * err_no,(数值) 返回代码  为0 表示正常，错误代码 参考https://www.chaojiying.com/api-23.html
    * err_str,(字符串) 中文描述的返回信息 
    * pic_id,(字符串) 图片标识号，或图片id号
    * pic_str,(字符串) 识别出的结果
    * md5,(字符串) md5校验值,用来校验此条数据返回是否真实有效
    */
    async getCaptcha(filePath, username, password, softId, codeType, lenMin = 0){
        let fileBase64 = await fs.readFileSync(filePath, 'base64');
        return new Promise((resolve) => {
            restler.post('http://upload.chaojiying.net/Upload/Processing.php', {
                multipart: true,
                data: {
                    'user': username,
                    'pass': password,
                    'softid':softId, 
                    'codetype': codeType,
                    'len_min':lenMin,
                    'file_base64': fileBase64
                },
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:24.0) Gecko/20100101 Firefox/24.0',
                    'Content-Type' : 'application/x-www-form-urlencoded' 
                }
            }).on('complete', function(data) {
                resolve(data);
            });
        });
    }

    /**识别报错返分
    * @param {string} username 用户名
    * @param {string} password 密码
    * @param {string} softId 软件ID
    * @param {string} picId 图片ID 对应 getCaptcha返回值的pic_id 字段
    * @return {Promise.<{err_no:number, err_str:string}>} 返回JSON
    * err_no,(数值) 返回代码
    * err_str,(字符串) 中文描述的返回信息
    */
    async errorCaptcha(username, password, softId, picId){
        return new Promise((resolve) => {
            restler.post('http://upload.chaojiying.net/Upload/ReportError.php', {
                multipart: true,
                data: {
                    'user': username,
                    'pass': password,
                    'softid':softId, 
                    'id': picId,
                },
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:24.0) Gecko/20100101 Firefox/24.0',
                    'Content-Type' : 'application/x-www-form-urlencoded' 
                }
            }).on('complete', function(data) {
                resolve(data);
            });
        });
    }

    /**查询验证码剩余题分
    * @param {string} username 用户名
    * @param {string} password 密码
    * @return {Promise.<{err_no:number, err_str:string, tifen:string, tifen_lock:string}>} 返回JSON
    * err_no,(数值) 返回代码
    * err_str,(字符串) 中文描述的返回信息
    * tifen,(数值) 题分
    * tifen_lock,(数值) 锁定题分
    */
    async scoreCaptcha(username, password){
        return new Promise((resolve) => {
            restler.post('http://upload.chaojiying.net/Upload/GetScore.php', {
                multipart: true,
                data: {
                    'user': username,
                    'pass': password,
                },
                headers: { 
                    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:24.0) Gecko/20100101 Firefox/24.0',
                    'Content-Type' : 'application/x-www-form-urlencoded' 
                }
            }).on('complete', function(data) {
                resolve(data);
            });
        });
    }

    /**初始化NLP
     * @param {string} aipKey 密钥
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async initNLP(aipKey){
        let strData = this.setSendData("initNLP", aipKey);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**chatGpt
     * @param {string} model, 指定使用的模型,"gpt-3.5-turbo"、text-davinci-003"、"text-curie-001"、"text-babbage-001"、"text-ada-001"和自定义微调模型
     * @param {string} promptOrMessages, 提出的问题，当model = "gpt-3.5-turbo"时，提问格式为 '[{"role": "user", "content": "你好！"}]' 。role 角色，content 问题内容
     * @param {number} maxTokens, 最大令牌数，大约 3个字符1个令牌，1个汉字2个令牌
     * @param {number} temperature, 浮点型，温度，调节结果的创意程度，0一般为单一结果， 1创意度更高
     * @param {string} stop, 可选参数，停止结果输出标志，一般用在微调模型上，例如 stop = '["END"]'
     * @return {Promise.<{text:string, finish:boolean} || null>} 失败返回null, 成功返回json对象
     * text 返回的答案内容
     * finish 为true回答结束，false 还有未输出的答案。我们可以继续 promptOrMessages + 输出的答案 获取后续内容，直到finish为true
    */
     async chatgpt(model, promptOrMessages, maxTokens, temperature, stop = ""){
        let strData = this.setSendData("chatgpt", model, promptOrMessages, maxTokens, temperature, stop);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);
    }

    /**chatGpt编辑模式
     * @param {string} model, 指定使用的模型， "text-davinci-edit-001"、"code-davinci-edit-001"
     * @param {string} input, 输入要编辑的内容
     * @param {string} instruction, 提示如何去编辑
     * @param {number} maxTokens, 最大令牌数，大约 3个字符1个令牌，1个汉字2个令牌
     * @param {number} temperature, 浮点型，温度，调节结果的创意程度，0一般为单一结果， 1创意度更高
     * @return {Promise.<{text:string, finish:boolean} || null>} 失败返回null, 成功返回json对象
     * text 返回的答案内容
     * finish 为true回答结束，false 还有未输出的答案。我们可以继续 prompt + 输出的答案 获取后续内容，直到finish为true
    */
    async chatgptEdit(model, input, instruction, maxTokens, temperature){
        let strData = this.setSendData("chatgptEdit", model, input, instruction, maxTokens, temperature);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);
    }

    /**创建微调模型
     * @param {string} fileId, 文件id，可通过 uploadTrainFile函数上传并获取文件id
     * @param {string} baseModel, 基础模型，可以是以下参数之一，"ada", "babbage", "curie", "davinci"和自定义微调模型
     * @param {string} suffix, 微调生成的模型名称后缀
     * @return {Promise.<string>} 成功返回微调id，失败返回null
    */
     async createFineTune(fileId, baseModel, suffix){
        let strData = this.setSendData("createFineTune", fileId, baseModel, suffix);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**列出所有微调信息
     * @return {Promise.<{[{baseModel:string, object:string, fineTuneId:string, fineTunedModel:string, fineTuneStatus:string, fileName:string, fileId:strinig, fileStatus:string}, ...] || null}>} 
     * 成功返回json对象 数组，失败返回null
     * baseModel 基础模型，一般是"ada", "babbage", "curie", "davinci"
     * object 
     * fineTuneId 微调id
     * fineTunedModel 微调模型的名称
     * fineTuneStatus 正在微调模型的进度状态
     * fileName 训练数据文件的名称
     * fileId 训练数据文件的id
     * fileStatus 训练数据文件的状态
    */
     async listFineTunes(){
        let strData = this.setSendData("listFineTunes");
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);
    }

    /**获取指定微调id的详细信息
     * @param {string} fineTuneId, 微调id
     * @return {Promise.<{baseModel:string, fineTuneCosts:string, fineTunedModel:string, fineTuneStatus:string, fileName:string, fileId:string,  fileStatus:string} || null>} 
     * 成功返回json对象，失败返回null
     * baseModel 基础模型，一般是"ada", "babbage", "curie", "davinci"
     * fineTuneCosts 训练该模型消耗的$
     * fineTunedModel 微调模型的名称
     * fineTuneStatus 正在微调模型的进度状态
     * fileName 训练数据文件的名称
     * fileId 训练数据文件的id
     * fileStatus 训练数据文件的状态
    */
    async listFineTune(fineTuneId){
        let strData = this.setSendData('listFineTune', fineTuneId);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);
    }

    /**取消正在微调的作业
     * @param {string} fineTuneId, 微调id
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async cancelFineTune(fineTuneId){
        let strData = this.setSendData('cancelFineTune', fineTuneId);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**删除微调模型
     * @param {string} fineTuneId, 微调id
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async deleteFineTuneModel(fineTuneId){
        let strData = this.setSendData('deleteFineTuneModel', fineTuneId);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**上传训练文件到服务器
     * @param {string} filePath, 文件路径，不支持中文路径
     * @return {Promise.<string>} 成功返回文件id，失败返回null
    */
    async uploadTrainFile(filePath){
        let strData = this.setSendData('uploadTrainFile', filePath);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**列出所有训练文件信息
     * @return {Promise.<[{bytes:number, fileName:string, fileId:string, purpose:string}] || null>} 成功返回json对象 数组，失败返回null
     * bytes 训练数据文件的大小
     * fileName 训练数据文件的名称
     * fileId 训练数据文件的id
     * purpose 文件的意图 例如："fine-tune" 意图为 用作微调模型
    */
     async listTrainFiles(){
        let strData = this.setSendData('listTrainFiles');
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);   
    }

    /**列出指定id的文件信息
     * @param {string} fileId, 文件id
     * @return {Promise.<{bytes:number, fileName:string, fileId:string, purpose:string} || null>} 成功返回json对象，失败返回null
     * bytes 训练数据文件的大小
     * fileName 训练数据文件的名称
     * fileId 训练数据文件的id
     * purpose 文件的意图 例如："fine-tune" 意图为 用作微调模型
    */
     async listTrainFile(fileId){
        let strData = this.setSendData('listTrainFile', fileId);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return JSON.parse(strRet);  
    }

    /**下载训练文件内容
     * @param {string} fileId, 文件id
     * @return {Promise.<string>} 成功返回文件内容，失败返回null
    */
    async downloadTrainFile(fileId){
        let strData = this.setSendData('downloadTrainFile', fileId);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;  
    }

    /**删除训练文件
     * @param {string} fileId, 文件id
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async deleteTrainFile(fileId){
        let strData = this.setSendData('deleteTrainFile', fileId);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

   /**激活 initSpeechService (不支持win7)
     * @param {string} activateKey, 激活密钥，联系管理员
     * @return {Promise.<boolean>} 成功返回true 失败返回false
    */
   async activateSpeechService(activateKey){
        let strData = this.setSendData('activateSpeechService', activateKey);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**初始化语音服务(不支持win7)，需要调用 activateSpeechService 激活
     * @param {string} speechKey, 密钥
     * @param {string} speechRegion, 区域
     * @return {Promise.<boolean>} 成功返回true 失败返回false
    */
    async initSpeechService(speechKey, speechRegion){
        let strData = this.setSendData('initSpeechService', speechKey, speechRegion);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**音频文件转文本
     * @param {string} filePath, 音频文件路径
     * @param {string} language, 语言，参考开发文档 语言和发音人
     * @return {Promise.<string || null>} 成功返回转换后的音频文本，失败返回null
    */
    async audioFileToText(filePath, language){
        let strData = this.setSendData('audioFileToText', filePath, language);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;  
    }

    /**麦克风输入流转换文本
     * @param {string} language, 语言，参考开发文档 语言和发音人
     * @return {Promise.<string || null>} 成功返回转换后的音频文本，失败返回null
    */
    async microphoneToText(language){
        let strData = this.setSendData('microphoneToText', language);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**文本合成音频到扬声器
     * @param {string} ssmlPathOrText，要转换语音的文本或者".xml"格式文件路径
     * @param {string} language，语言，参考开发文档 语言和发音人
     * @param {string} voiceName，发音人，参考开发文档 语言和发音人
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async textToBullhorn(ssmlPathOrText, language, voiceName){
        let strData = this.setSendData("textToBullhorn", ssmlPathOrText, language, voiceName);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**文本合成音频并保存到文件
     * @param {string} ssmlPathOrText，要转换语音的文本或者".xml"格式文件路径
     * @param {string} language，语言，参考开发文档 语言和发音人
     * @param {string} voiceName，发音人，参考开发文档 语言和发音人
     * @param {string} audioPath，保存音频文件路径
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async textToAudioFile(ssmlPathOrText, language, voiceName, audioPath){
        let strData = this.setSendData("textToAudioFile", ssmlPathOrText, language, voiceName, audioPath);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**麦克风音频翻译成目标语言文本
     * @param {string} sourceLanguage，要翻译的语言，参考开发文档 语言和发音人
     * @param {string} targetLanguage，翻译后的语言，参考开发文档 语言和发音人
     * @return {Promise.<string || null>} 成功返回翻译后的语言文本，失败返回null
    */
    async microphoneTranslationText(sourceLanguage, targetLanguage){
        let strData = this.setSendData("microphoneTranslationText", sourceLanguage, targetLanguage);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**音频文件翻译成目标语言文本
     * @param {string} audioPath， 要翻译的音频文件路径
     * @param {string} sourceLanguage，要翻译的语言，参考开发文档 语言和发音人
     * @param {string} targetLanguage，翻译后的语言，参考开发文档 语言和发音人
     * @return {Promise.<string || null>}成功返回翻译后的语言文本，失败返回null
    */
    async audioFileTranslationText(audioPath, sourceLanguage, targetLanguage){
        let strData = this.setSendData("audioFileTranslationText", audioPath, sourceLanguage, targetLanguage);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "null")
            return null;
        else
            return strRet;
    }

    /**初始化数字人，第一次初始化需要一些时间
     * @param {string} metahumanModePath, 数字人模型路径
     * @param {number} metahumanScaleValue, 数字人缩放倍数，1为原始大小。为0.5时放大一倍，2则缩小一半
     * @param {boolean} isUpdateMetahuman, 是否强制更新，默认fasle。为true时强制更新会拖慢初始化速度
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
     async initMetahuman(metahumanModePath, metahumanScaleValue, isUpdateMetahuman = false){
        let strData = this.setSendData("initMetahuman", metahumanModePath, metahumanScaleValue, isUpdateMetahuman);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**数字人说话，此函数需要调用 initSpeechService 初始化语音服务
     * @param {string} saveVoiceFolder, 保存的发音文件目录，文件名以0开始依次增加，扩展为.wav格式
     * @param {string} text,要转换语音的文本
     * @param {string} language，语言，参考开发文档 语言和发音人
     * @param {string} voiceName，发音人，参考开发文档 语言和发音人
     * @param {number} quality，音质，0低品质  1中品质  2高品质， 默认为0低品质
     * @param {boolean} waitPlaySound，等待音频播报完毕，默认为 true等待
     * @param {number} speechRate， 语速，默认为0，取值范围 -100 至 200
     * @param {string} voiceStyle，语音风格，默认General常规风格，其他风格参考开发文档 语言和发音人
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
     async metahumanSpeech(saveVoiceFolder, text, language, voiceName, quality = 0, waitPlaySound = true, speechRate = 0, voiceStyle = "General"){
        let strData = this.setSendData("metahumanSpeech", saveVoiceFolder, text, language, voiceName, quality, waitPlaySound, speechRate, voiceStyle);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }
    
    /**数字人说话缓存模式，需要调用 initSpeechService 初始化语音服务。函数一般用于常用的话术播报，非常用话术切勿使用，否则内存泄漏
     * @param {string} saveVoiceFolder, 保存的发音文件目录，文件名以0开始依次增加，扩展为.wav格式
     * @param {string} text,要转换语音的文本
     * @param {string} language，语言，参考开发文档 语言和发音人
     * @param {string} voiceName，发音人，参考开发文档 语言和发音人
     * @param {number} quality，音质，0低品质  1中品质  2高品质， 默认为0低品质
     * @param {boolean} waitPlaySound，等待音频播报完毕，默认为 true等待
     * @param {number} speechRate， 语速，默认为0，取值范围 -100 至 200
     * @param {string} voiceStyle，语音风格，默认General常规风格，其他风格参考开发文档 语言和发音人
     * @return {Promise.<boolean>} 成功返回true，失败返回false
    */
    async metahumanSpeechCache(saveVoiceFolder, text, language, voiceName, quality = 0, waitPlaySound = true, speechRate = 0, voiceStyle = "General"){
        let strData = this.setSendData("metahumanSpeechCache", saveVoiceFolder, text, language, voiceName, quality, waitPlaySound, speechRate, voiceStyle);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**数字人插入视频
     * @param {string} videoFilePath, 插入的视频文件路径
     * @param {string} audioFilePath, 插入的音频文件路径
     * @param {boolean} waitPlayVideo，等待视频播放完毕，默认为 true等待
     * @return {Promise.<boolean>} 总是返回true。 此函数依赖 initMetahuman函数运行，否则程序会崩溃
    */
    async metahumanInsertVideo(videoFilePath, audioFilePath, waitPlayVideo = true){
        let strData = this.setSendData("metahumanInsertVideo", videoFilePath, audioFilePath, waitPlayVideo);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**替换数字人背景
     * @param {string} bgFilePath,数字人背景 图片/视频 路径，默认不替换背景。仅替换绿幕背景的数字人模型
     * @param {number} replaceRed, 数字人背景的三通道之一的 R通道色值。默认-1 自动提取
     * @param {number} replaceGreen, 数字人背景的三通道之一的 G通道色值。默认-1 自动提取
     * @param {number} replaceBlue, 数字人背景的三通道之一的 B通道色值。默认-1 自动提取
     * @param {number} simValue, 相似度。 默认为0，取值应当大于等于0
     * @return {Promise.<boolean>} 总是返回true。此函数依赖 initMetahuman函数运行，否则程序会崩溃
    */
    async replaceBackground(bgFilePath, replaceRed = -1, replaceGreen = -1, replaceBlue = -1, simValue = 0){
        let strData = this.setSendData("replaceBackground", bgFilePath, replaceRed, replaceGreen, replaceBlue, simValue);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**显示数字人说话的文本
     * @param {number} originY, 第一个字显示的起始Y坐标点。 默认0 自适应高度
     * @param {string} fontType, 字体样式，支持操作系统已安装的字体。例如"Arial"、"微软雅黑"、"楷体"
     * @param {number} fontSize, 字体的大小。默认30
     * @param {number} fontRed, 字体颜色三通道之一的 R通道色值。默认128
     * @param {number} fontGreen, 字体颜色三通道之一的 G通道色值。默认255
     * @param {number} fontBlue, 字体颜色三通道之一的 B通道色值。默认0
     * @param {boolean} italic, 是否斜体,默认false
     * @param {boolean} underline, 是否有下划线,默认false
     * @return {Promise.<boolean>} 总是返回true。此函数依赖 initMetahuman函数运行，否则程序会崩溃
    */
    async showSpeechText(originY = 0, fontType = "Arial", fontSize = 30, fontRed = 128, fontGreen = 255, fontBlue = 0, italic = false, underline = false){
        let strData = this.setSendData("showSpeechText", originY, fontType, fontSize, fontRed, fontGreen, fontBlue, italic, underline);
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        if(strRet == "false")
            return false;
        else
            return true;
    }

    /**获取WindowsDriver.exe 命令扩展参数，一般用作脚本远程部署场景，WindowsDriver.exe驱动程序传递参数给脚本服务端
     * @return {Promise.<string>} 返回WindowsDriver驱动程序的命令行参数(不包含ip和port)
    */
    async getExtendParam(){
        let strData = this.setSendData("getExtendParam");
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return strRet;
    }

    /**关闭WindowsDriver.exe驱动程序
     * @return {Promise.<void>}
    */
    async closeDriver(){
        let strData = this.setSendData("closeDriver");
        let byteRet = await this.sendData(strData);
        let strRet = byteRet.toString();
        return ;
    }
}

class Mutex {
    constructor () {
        this.queue = [];
        this.locked = false;
    }

    lock () {
        return new Promise((resolve, reject) => {
            if (this.locked) {
                this.queue.push([resolve, reject]);
            } else {
                this.locked = true;
                resolve();
            }
        });
    }

    release () {
        if (this.queue.length > 0) {
            const [resolve, reject] = this.queue.shift();
            resolve();
        } else {
            this.locked = false;
        }
    }
}

module.exports = WindowsBot;